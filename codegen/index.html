<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCXML Code Generator - Online</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        header { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        header h1 { color: #333; margin-bottom: 5px; }
        header p { color: #666; }

        .editor-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .editor-pane { background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; flex-direction: column; }

        .editor-pane-header { display: flex; background: #f0f0f0; border-bottom: 2px solid #e0e0e0; }
        .tab {
            flex: 1;
            padding: 15px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
            border: none;
            background: none;
            transition: all 0.2s ease;
            font-weight: 500;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        .tab:hover { color: #333; background: #f8f8f8; }
        .tab.active {
            color: #007bff;
            border-bottom-color: #007bff;
            background: white;
        }

        .tab-content { display: none; flex: 1; }
        .tab-content.active { display: flex; flex-direction: column; }

        textarea { width: 100%; height: 400px; padding: 15px; border: none; resize: none; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px; }
        pre { width: 100%; flex: 1; padding: 15px; overflow: auto; border: none; background: #f8f8f8; color: #333; font-family: 'Monaco', 'Courier New', monospace; font-size: 11px; margin: 0; }

        .controls { display: flex; gap: 10px; padding: 15px; background: white; border-radius: 8px; margin-bottom: 20px; }
        button { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: background 0.2s; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        .status { padding: 15px; background: white; border-radius: 8px; margin-bottom: 20px; display: none; }
        .status.show { display: block; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.loading { background: #e2e3e5; color: #383d41; border: 1px solid #d6d8db; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SCXML Code Generator</h1>
            <p>Generate optimized C++ code from SCXML state machine definitions</p>
        </header>

        <div class="status" id="status"></div>

        <div class="controls">
            <button onclick="generateCode()" id="generateBtn">Generate C++ Code</button>
            <button onclick="downloadCode()" id="downloadBtn" disabled>Download Code</button>
            <button onclick="clearAll()">Clear All</button>
        </div>

        <div class="editor-section">
            <!-- Left: SCXML Input -->
            <div class="editor-pane">
                <div class="editor-pane-header">
                    <div style="padding: 15px; font-weight: 500; color: #333;">Input: SCXML</div>
                </div>
                <textarea id="scxmlInput" placeholder="Paste your SCXML here...">&lt;?xml version="1.0"?&gt;
&lt;scxml xmlns="http://www.w3.org/2005/07/scxml" version="1.0" initial="off" name="simple"&gt;
  &lt;state id="off"&gt;
    &lt;transition event="switch_on" target="on"/&gt;
  &lt;/state&gt;
  &lt;state id="on"&gt;
    &lt;transition event="switch_off" target="off"/&gt;
  &lt;/state&gt;
&lt;/scxml&gt;</textarea>
            </div>

            <!-- Right: Output with Tabs -->
            <div class="editor-pane">
                <div class="editor-pane-header">
                    <button class="tab active" onclick="switchTab('generated')">Generated Code</button>
                    <button class="tab" onclick="switchTab('example')">Usage Example</button>
                </div>
                <pre id="generatedContent" class="tab-content active">Ready to generate...</pre>
                <pre id="exampleContent" class="tab-content"></pre>
            </div>
        </div>
    </div>

    <script src="scxml-codegen.js"></script>
    <script>
        let generatedCode = '';
        let exampleCode = '';

        function showStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status show ' + type;
        }

        function clearStatus() {
            const status = document.getElementById('status');
            status.className = 'status';
        }

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(function(btn) {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(function(content) {
                content.classList.remove('active');
            });

            if (tab === 'generated') {
                document.getElementById('generatedContent').classList.add('active');
            } else {
                document.getElementById('exampleContent').classList.add('active');
            }
        }

        function generateCode() {
            const scxmlInput = document.getElementById('scxmlInput').value;
            const btn = document.getElementById('generateBtn');

            if (!scxmlInput.trim()) {
                showStatus('Please enter SCXML code', 'error');
                return;
            }

            btn.disabled = true;
            showStatus('Generating C++ code...', 'loading');

            try {
                // Parse SCXML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(scxmlInput, 'application/xml');

                if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
                    throw new Error('Invalid SCXML: ' + xmlDoc.getElementsByTagName('parsererror')[0].textContent);
                }

                const stateMachine = xmlDoc.getElementsByTagName('scxml')[0];
                const states = Array.from(xmlDoc.getElementsByTagName('state'));
                const smName = stateMachine.getAttribute('name') || 'StateMachine';
                const initialState = stateMachine.getAttribute('initial');

                if (!initialState) {
                    throw new Error('SCXML must have an initial state attribute');
                }

                // Collect all unique events from transitions
                const eventsSet = new Set();
                states.forEach(function(state) {
                    const transitions = state.getElementsByTagName('transition');
                    Array.from(transitions).forEach(function(trans) {
                        const event = trans.getAttribute('event');
                        if (event) eventsSet.add(event);
                    });
                });
                const events = Array.from(eventsSet).sort();

                // Generate full C++ code structure
                let code = '#pragma once\n' +
                    '#include <cstdint>\n' +
                    '#include <memory>\n' +
                    '#include <stdexcept>\n' +
                    '#include <string>\n' +
                    '#include <unordered_map>\n' +
                    '#include "static/StaticExecutionEngine.h"\n' +
                    '#include "common/TransitionHelper.h"\n' +
                    '\n' +
                    'namespace RSM::Generated::' + smName + ' {\n' +
                    '\n' +
                    'class ' + smName + ';\n' +
                    '\n' +
                    'enum class State : uint8_t {\n';

                // State enum
                states.forEach(function(state, idx) {
                    const stateId = state.getAttribute('id');
                    const stateName = stateId[0].toUpperCase() + stateId.slice(1);
                    code += '    ' + stateName + (idx < states.length - 1 ? ',' : '') + '\n';
                });

                code += '};\n\n' +
                    'enum class Event : uint8_t {\n' +
                    '    NONE,  // W3C SCXML 6.2: Default event for scheduler polling\n';
                
                events.forEach(function(event, idx) {
                    const eventName = event.toUpperCase().replace(/\./g, '_');
                    code += '    ' + eventName + (idx < events.length - 1 ? ',' : '') + '\n';
                });

                code += '};\n\n' +
                    '// State policy for ' + smName + '\n' +
                    'struct ' + smName + 'Policy {\n' +
                    '    using State = ::RSM::Generated::' + smName + '::State;\n' +
                    '    using Event = ::RSM::Generated::' + smName + '::Event;\n' +
                    '\n' +
                    '    // Default constructor\n' +
                    '    ' + smName + 'Policy() = default;\n' +
                    '\n' +
                    '    static State initialState() {\n' +
                    '        return State::' + (initialState[0].toUpperCase() + initialState.slice(1)) + ';\n' +
                    '    }\n' +
                    '\n' +
                    '    static bool isFinalState(State state) {\n' +
                    '        switch (state) {\n' +
                    '            default:\n' +
                    '                return false;\n' +
                    '        }\n' +
                    '    }\n' +
                    '\n' +
                    '    static std::optional<State> getParent(State state) {\n' +
                    '        switch (state) {\n' +
                    '            default:\n' +
                    '                return std::nullopt;  // Root state\n' +
                    '        }\n' +
                    '    }\n' +
                    '\n' +
                    '    template<typename Engine>\n' +
                    '    static void executeEntryActions(State state, Engine& engine) {\n' +
                    '        (void)engine;\n' +
                    '        switch (state) {\n';

                states.forEach(function(state) {
                    const stateId = state.getAttribute('id');
                    const stateName = stateId[0].toUpperCase() + stateId.slice(1);
                    code += '            case State::' + stateName + ':\n' +
                            '                break;\n';
                });

                code += '            default:\n' +
                    '                break;\n' +
                    '        }\n' +
                    '    }\n' +
                    '\n' +
                    '    template<typename Engine>\n' +
                    '    static void executeExitActions(State state, Engine& engine) {\n' +
                    '        (void)engine;\n' +
                    '        switch (state) {\n';

                states.forEach(function(state) {
                    const stateId = state.getAttribute('id');
                    const stateName = stateId[0].toUpperCase() + stateId.slice(1);
                    code += '            case State::' + stateName + ':\n' +
                            '                break;\n';
                });

                code += '            default:\n' +
                    '                break;\n' +
                    '        }\n' +
                    '    }\n' +
                    '\n' +
                    '    template<typename Engine>\n' +
                    '    static bool processTransition(State& currentState, Event event, Engine& engine) {\n' +
                    '        (void)engine;\n' +
                    '        bool transitionTaken = false;\n' +
                    '\n' +
                    '        State checkState = currentState;\n' +
                    '        while (true) {\n' +
                    '            bool foundTransition = tryTransitionInState(checkState, event, currentState, transitionTaken, engine);\n' +
                    '            if (foundTransition) break;\n' +
                    '\n' +
                    '            auto parent = ' + smName + 'Policy::getParent(checkState);\n' +
                    '            if (!parent.has_value()) break;\n' +
                    '            checkState = parent.value();\n' +
                    '        }\n' +
                    '\n' +
                    '        return transitionTaken;\n' +
                    '    }\n' +
                    '\n' +
                    'private:\n' +
                    '    template<typename Engine>\n' +
                    '    static bool tryTransitionInState(State checkState, Event event, State& currentState, bool& transitionTaken, Engine& engine) {\n' +
                    '        switch (checkState) {\n';

                // Generate transitions
                states.forEach(function(state) {
                    const stateId = state.getAttribute('id');
                    const stateName = stateId[0].toUpperCase() + stateId.slice(1);
                    code += '        case State::' + stateName + ':\n';

                    const transitions = Array.from(state.getElementsByTagName('transition'))
                        .filter(function(t) { return t.getAttribute('event') && t.getAttribute('target'); });

                    if (transitions.length > 0) {
                        transitions.forEach(function(trans) {
                            const event = trans.getAttribute('event');
                            const target = trans.getAttribute('target');
                            const eventName = event.toUpperCase().replace(/\./g, '_');
                            const targetName = target[0].toUpperCase() + target.slice(1);
                            code += '            if (event == Event::' + eventName + ') {\n' +
                                    '                currentState = State::' + targetName + ';\n' +
                                    '                transitionTaken = true;\n' +
                                    '                return true;\n' +
                                    '            }\n';
                        });
                    }
                    code += '            return false;\n';
                });

                code += '        default:\n' +
                    '            return false;\n' +
                    '        }\n' +
                    '    }\n' +
                    '\n' +
                    'public:\n' +
                    '    static std::string getEventName(Event event) {\n' +
                    '        switch (event) {\n' +
                    '            case Event::NONE: return "";\n';

                events.forEach(function(event) {
                    const eventName = event.toUpperCase().replace(/\./g, '_');
                    code += '            case Event::' + eventName + ': return "' + event + '";\n';
                });

                code += '            default: return "";\n' +
                    '        }\n' +
                    '    }\n' +
                    '};\n' +
                    '\n' +
                    '// User-facing state machine class\n' +
                    'class ' + smName + ' : public ::RSM::Static::StaticExecutionEngine<' + smName + 'Policy> {\n' +
                    'public:\n' +
                    '    ' + smName + '() = default;\n' +
                    '};\n' +
                    '\n' +
                    '} // namespace RSM::Generated::' + smName + '\n';

                // Generate usage example
                let example = '#include "' + smName + '_sm.h"\n' +
                    '#include <iostream>\n' +
                    '\n' +
                    'int main() {\n' +
                    '    // Create state machine instance\n' +
                    '    RSM::Generated::' + smName + '::' + smName + ' sm;\n' +
                    '\n' +
                    '    // Initialize state machine\n' +
                    '    // This enters the initial state and processes any eventless transitions\n' +
                    '    sm.initialize();\n' +
                    '\n' +
                    '    std::cout << "Initial state: " << sm.getStateName() << std::endl;\n' +
                    '\n' +
                    '    // Process events\n';

                // Generate example event processing
                const firstEvent = events[0];
                if (firstEvent) {
                    const eventName = firstEvent.toUpperCase().replace(/\./g, '_');
                    example += '\n' +
                        '    std::cout << "\\nSending event: ' + firstEvent + '" << std::endl;\n' +
                        '    sm.processEvent(RSM::Generated::' + smName + '::Event::' + eventName + ');\n' +
                        '    std::cout << "Current state: " << sm.getStateName() << std::endl;';
                }

                example += '\n' +
                    '\n' +
                    '    std::cout << "\\n✅ State machine working correctly!" << std::endl;\n' +
                    '    return 0;\n' +
                    '}\n';

                generatedCode = code;
                exampleCode = example;

                document.getElementById('generatedContent').textContent = generatedCode;
                document.getElementById('exampleContent').textContent = exampleCode;
                document.getElementById('downloadBtn').disabled = false;
                clearStatus();
                showStatus('Code generated successfully!', 'success');
            } catch (e) {
                showStatus('Error: ' + e.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        function downloadCode() {
            if (!generatedCode) {
                showStatus('No code to download', 'error');
                return;
            }

            const blob = new Blob([generatedCode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'generated_sm.h';
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearAll() {
            document.getElementById('scxmlInput').value = '';
            document.getElementById('generatedContent').textContent = 'Ready to generate...';
            document.getElementById('exampleContent').textContent = '';
            document.getElementById('downloadBtn').disabled = true;
            generatedCode = '';
            exampleCode = '';
            clearStatus();

            // Reset to generated code tab
            document.querySelectorAll('.tab').forEach(function(btn) { btn.classList.remove('active'); });
            document.querySelectorAll('.tab-content').forEach(function(content) { content.classList.remove('active'); });
            document.querySelectorAll('.tab')[0].classList.add('active');
            document.getElementById('generatedContent').classList.add('active');
        }

        // Check WASM module loading
        if (typeof Module !== 'undefined') {
            Module.onRuntimeInitialized = function() {
                Module.ready = true;
                console.log('WASM module ready');
                clearStatus();
            };
        }
    </script>
</body>
</html>
