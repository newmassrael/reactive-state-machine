    // Helper: Ensure session ID is initialized
    void ensureSessionId() const {
        if (!sessionId_.has_value()) {
            sessionId_ = "session_" + std::to_string(reinterpret_cast<uintptr_t>(this));
        }
    }

{% if model.needs_jsengine %}
    // Helper: Ensure JSEngine is initialized (lazy initialization)
    void ensureJSEngine() const {
        if (jsEngineInitialized_) return;
        ensureSessionId();
        if (!sessionId_.has_value()) return;
        auto& jsEngine = ::RSM::JSEngine::instance();
        jsEngine.createSession(sessionId_.value());

{% for var in model.variables %}
{% if var.expr %}
        auto initExpr_{{ var.id }} = jsEngine.evaluateExpression(sessionId_.value(), "{{ var.expr | escape_cpp }}").get();
        if (!::RSM::JSEngine::isSuccess(initExpr_{{ var.id }})) {
            LOG_ERROR("Failed to evaluate expression for variable: {{ var.id }}");
        } else {
            jsEngine.setVariable(sessionId_.value(), "{{ var.id }}", initExpr_{{ var.id }}.getInternalValue());
        }
{% elif var.content %}
        auto initExpr_{{ var.id }} = jsEngine.evaluateExpression(sessionId_.value(), R"({{ var.content | escape_cpp }})").get();
        if (!::RSM::JSEngine::isSuccess(initExpr_{{ var.id }})) {
            LOG_ERROR("Failed to evaluate expression for variable: {{ var.id }}");
        } else {
            jsEngine.setVariable(sessionId_.value(), "{{ var.id }}", initExpr_{{ var.id }}.getInternalValue());
        }
{% elif var.type == 'runtime' %}
        auto initExpr_{{ var.id }} = jsEngine.evaluateExpression(sessionId_.value(), "undefined").get();
        if (!::RSM::JSEngine::isSuccess(initExpr_{{ var.id }})) {
            LOG_ERROR("Failed to evaluate expression for variable: {{ var.id }}");
        } else {
            jsEngine.setVariable(sessionId_.value(), "{{ var.id }}", initExpr_{{ var.id }}.getInternalValue());
        }
{% endif %}
{% endfor %}

{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 5.9.2: Register state query callback for In() predicate support
        // ARCHITECTURE.md All-or-Nothing Strategy: Static AOT engines cannot hold StateMachine*
        // pointers (no base class). Callback mechanism provides In() capability while maintaining
        // compile-time static structure. isStateActive() uses InPredicateHelper for shared logic.
        jsEngine.setStateQueryCallback(
            [this](const std::string& stateId) { return this->isStateActive(stateId); },
            sessionId_.value()
        );
        LOG_DEBUG("AOT ensureJSEngine: Registered state query callback for In() predicate");
{% endif %}

        jsEngineInitialized_ = true;
    }

    // ARCHITECTURE.MD: Zero Duplication - Use DataModelInitHelper (shared with Interpreter)
    // W3C SCXML 5.2/5.3: Initialize datamodel and raise error.execution if failed
    // Called during StaticExecutionEngine::initialize() to ensure proper error event timing
    template<typename Engine>
    void initializeDataModel(Engine& engine) {
        if (jsEngineInitialized_) return;
        ensureSessionId();
        if (!sessionId_.has_value()) return;
        auto& jsEngine = ::RSM::JSEngine::instance();
        jsEngine.createSession(sessionId_.value());
{% if not model.variables %}
        (void)engine;  // No variables to initialize
{% endif %}

{% for var in model.variables %}
{% if var.expr %}
        // W3C SCXML 5.2/5.3: Use shared Helper for datamodel initialization
        ::RSM::DataModelInitHelper::initializeVariable(
            jsEngine, sessionId_.value(), "{{ var.id }}", "{{ var.expr | escape_cpp }}",
            [&engine](const ::std::string& msg) {
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
            });
{% elif var.content %}
        ::RSM::DataModelInitHelper::initializeVariable(
            jsEngine, sessionId_.value(), "{{ var.id }}", R"({{ var.content | escape_cpp }})",
            [&engine](const ::std::string& msg) {
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
            });
{% elif var.type == 'runtime' %}
        ::RSM::DataModelInitHelper::initializeVariable(
            jsEngine, sessionId_.value(), "{{ var.id }}", "",
            [&engine](const ::std::string& msg) {
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
            });
{% endif %}
{% endfor %}

{% if model.global_scripts %}
        // W3C SCXML 5.8: Execute global (top-level) scripts at document load time
        // ARCHITECTURE.md Zero Duplication: Matches Interpreter behavior (StateMachine.cpp execution order)
        // Execution order: datamodel init → global scripts → state machine start
{% for script in model.global_scripts %}
        {
            auto scriptResult = jsEngine.executeScript(sessionId_.value(), "{{ script.content | escape_cpp }}").get();
            if (!::RSM::JSEngine::isSuccess(scriptResult)) {
                std::string errorMsg = "Global script execution failed";
                LOG_ERROR("W3C SCXML 5.8: {}", errorMsg);
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, errorMsg));
            }
        }
{% endfor %}
{% endif %}

{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 5.9.2: Register state query callback for In() predicate support
        // ARCHITECTURE.md All-or-Nothing Strategy: Static AOT engines cannot hold StateMachine*
        // pointers (no base class). Callback mechanism provides In() capability while maintaining
        // compile-time static structure. isStateActive() uses InPredicateHelper for shared logic.
        jsEngine.setStateQueryCallback(
            [this](const std::string& stateId) { return this->isStateActive(stateId); },
            sessionId_.value()
        );
        LOG_DEBUG("AOT initializeDataModel: Registered state query callback for In() predicate");
{% endif %}

        jsEngineInitialized_ = true;
    }
{% endif %}
