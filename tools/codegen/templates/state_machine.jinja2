#pragma once
#include <cstdint>
#include <memory>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include "static/StaticExecutionEngine.h"
{% if model.static_invokes %}

// Child SCXML headers (static invokes)
{% for invoke_info in model.static_invokes %}
#include "{{ invoke_info.child_name }}_sm.h"
{% endfor %}
{% endif %}
{% if model.needs_send_helper %}
#include "common/SendHelper.h"
#include "common/NamelistHelper.h"
{% endif %}
{% if model.needs_event_scheduler %}
#include "common/SendSchedulingHelper.h"
{% endif %}
#include "common/TransitionHelper.h"
#include "common/HistoryHelper.h"
#include "common/EventMatchingHelper.h"
{% if model.has_parallel_states %}
#include "common/ParallelStateHelper.h"
#include "common/ParallelExitEntryHelper.h"
#include "common/ParallelTransitionHelper.h"
#include "common/HierarchicalStateHelper.h"
#include "common/ConflictResolutionHelper.h"
{% endif %}
{% if model.needs_event_data_helper %}
#include "common/EventDataHelper.h"
{% endif %}
{% if model.needs_donedata_helper %}
#include "common/DoneDataHelper.h"
{% endif %}
{% if model.needs_jsengine %}
#include "common/DataModelInitHelper.h"
#include "common/EventTypeHelper.h"
#include <optional>
#include "common/Logger.h"
#include "scripting/JSEngine.h"
#include "common/AssignHelper.h"
#include "common/ForeachValidator.h"
#include "common/ForeachHelper.h"
#include "common/GuardHelper.h"
#include "common/InPredicateHelper.h"
{% endif %}

namespace RSM::Generated::{{ model.name }} {

{% if model.has_parent_communication %}
template<typename ParentStateMachine>
{% endif %}
class {{ model.name }};

{# State enum #}
enum class State : uint8_t {
    {% for state_name in model.states | sort %}
    {{ state_name | capitalize }}{{ "," if not loop.last }}
    {% endfor %}
};

{# Event enum #}
enum class Event : uint8_t {
    NONE,  // W3C SCXML 6.2: Default event for scheduler polling (no semantic meaning)
    {% for event_name in model.events | sort %}
    {{ event_name | replace('.', '_') | capitalize }}{{ "," if not loop.last }}
    {% endfor %}
};

{# Transition descriptor for W3C SCXML Appendix D optimal transition set #}
/**
 * @brief Transition information for microstep execution
 *
 * W3C SCXML Appendix D: Optimal enabled transition set execution requires
 * collecting all enabled transitions before executing any (atomic microstep).
 */
struct TransitionInfo {
    State source;              // W3C SCXML 3.13: Source state of transition
    State target;              // Target state of transition
    int transitionIndex;       // Index of transition in source state (for executeTransitionActions)
    bool hasActions;           // Whether transition has executable content

    TransitionInfo(State src, State tgt, int idx, bool actions)
        : source(src), target(tgt), transitionIndex(idx), hasActions(actions) {}
};

{# Policy class #}
// State policy for {{ model.name }}
{% if model.has_parent_communication %}
template<typename ParentStateMachine>
{% elif model.static_invokes %}
template<typename SelfType>
{% endif %}
struct {{ model.name }}Policy {
    using State = ::RSM::Generated::{{ model.name }}::State;
    using Event = ::RSM::Generated::{{ model.name }}::Event;

    // W3C SCXML Appendix D: Flag indicating parallel state support
    static constexpr bool HAS_PARALLEL_STATES = {{ 'true' if model.has_parallel_states else 'false' }};

    {% if model.variables %}
    // Datamodel variables
    {% for var in model.variables %}
    {% if var.type == 'int' %}
    int {{ var.id }} = {{ var.expr if var.expr else '0' }};
    {% elif var.type == 'string' %}
    ::std::string {{ var.id }}{{ ' = ' + var.expr if var.expr else '' }};
    {% elif var.type == 'bool' %}
    bool {{ var.id }} = {{ var.expr if var.expr else 'false' }};
    {% elif var.type == 'runtime' %}
    // Runtime-evaluated variable (handled by JSEngine): {{ var.id }}
    {% endif %}
    {% endfor %}
    {% endif %}
    {% if model.has_parent_communication %}

    // W3C SCXML 6.2: Parent state machine pointer for #_parent support
    ParentStateMachine* parent_ = nullptr;
    
    // W3C SCXML 6.4.1: Invokeid for child-to-parent communication (test338)
    ::std::string invokeId_;
    {% endif %}

    {% if model.needs_jsengine or model.static_invokes %}
    // Session ID for JSEngine/Invoke (lazy-initialized)
    mutable ::std::optional<::std::string> sessionId_;
    {% endif %}
    {% if model.needs_jsengine %}
    mutable bool jsEngineInitialized_ = false;
    {% endif %}
    {% if model.needs_event_name %}
    // W3C SCXML 5.10: Event name storage for _event.name access (test318)
    mutable ::std::string pendingEventName_;
    {% endif %}
    {% if model.needs_event_data %}
    // W3C SCXML 5.10: Event data storage for _event.data access
    // Required for: <send> params, error.execution event data (W3C SCXML 5.3)
    mutable ::std::string pendingEventData_;
    {% endif %}
    {% if model.needs_event_type %}
    // W3C SCXML 5.10.1: Event type storage for _event.type access (test331)
    mutable ::std::string pendingEventType_;
    {% endif %}
    {% if model.needs_event_sendid %}
    // W3C SCXML 5.10.1: Event sendid storage for _event.sendid access (test332)
    mutable ::std::string pendingEventSendId_;
    {% endif %}
    {% if model.needs_event_origin %}
    // W3C SCXML 5.10.1: Event origin storage for _event.origin access (test336)
    mutable ::std::string pendingEventOrigin_;
    {% endif %}
    {% if model.needs_event_origintype %}
    // W3C SCXML 5.10.1: Event origintype storage for _event.origintype access
    mutable ::std::string pendingEventOriginType_;
    {% endif %}
    {% if model.needs_event_invokeid %}
    // W3C SCXML 5.10.1: Event invokeid storage for _event.invokeid access (test338)
    mutable ::std::string pendingEventInvokeId_;
    {% endif %}
    {% if model.needs_external_flag %}
    // W3C SCXML 6.2: Flag to mark next event as external (from send)
    mutable bool nextEventIsExternal_ = false;
    {% endif %}
    {% if model.static_invokes %}
    // W3C SCXML 5.10: Current event metadata (originSessionId for finalize)
    mutable ::RSM::Core::EventMetadata currentEventMetadata_;
    // W3C SCXML 6.4: Static invoke child state machines
    {% for invoke_info in model.static_invokes %}
    mutable std::shared_ptr<::RSM::Generated::{{ invoke_info.child_name }}::{{ invoke_info.child_name }}<SelfType>> child_{{ invoke_info.invoke_id }}_;
    {% endfor %}

    // W3C SCXML 6.4: Pending done.invoke flags for child completion
    {% for invoke_info in model.static_invokes %}
    mutable bool pendingDoneInvoke_{{ invoke_info.invoke_id }}_ = false;
    {% endfor %}

    // W3C SCXML 6.4: Child session tracking
    struct ChildSession {
        std::string sessionId;           // Child's session ID
        std::string invokeId;            // Invoke element ID
        std::string parentSessionId;     // Parent's session ID
        bool autoforward = false;        // W3C 6.4.1: Autoforward events to child
        std::string finalizeScript;      // W3C 6.5: Finalize handler script
    };

    // Active child sessions indexed by invokeId
    mutable std::unordered_map<std::string, ChildSession> activeInvokes_;
    {% endif %}
    {% if model.needs_event_scheduler %}
    // W3C SCXML 6.2: Event scheduler for delayed send (lazy-init)
    mutable ::RSM::SendSchedulingHelper::SimpleScheduler<Event> eventScheduler_;
    {% if model.needs_event_data_helper or model.needs_jsengine %}
    // W3C SCXML 5.10: Event data map for scheduled events with params (test186)
    mutable ::std::map<Event, ::std::string> scheduledEventData_;
    {% endif %}
    {% endif %}
    {% if model.history_states %}
    // W3C SCXML 3.11: Runtime history tracking variables (matches Interpreter HistoryEntry)
    {% for history_id, history_info in model.history_states.items() %}
    mutable ::std::optional<::std::vector<State>> history_{{ history_id }};  // {{ history_info.type }} history for {{ history_info.parent }}
    {% endfor %}
    {% endif %}
    {% if model.has_parallel_states or model.uses_in_predicate %}
    // W3C SCXML 3.4/3.12.1: Configuration - active states for parallel states and In() predicate
    // Tracks all currently active states (parallel regions can have multiple active states)
    // Also required for In() predicate to check state membership
    // Thread-safe: mutex protects access from JSEngine worker thread
    mutable ::std::vector<State> activeStates_;
    mutable ::std::mutex activeStatesMutex_;
    {% endif %}

    // W3C SCXML 3.13: Track last transition for deferred action execution
    // W3C SCXML 3.4: Also needed for parallel states to track actual transition source
    mutable State lastTransitionSourceState_{};
{% if model.has_transition_actions %}
    mutable size_t lastTransitionIndex_ = 0;
    mutable bool hasTransitionActions_ = false;
{% endif %}
    // Default constructor (lazy initialization, no immediate resource allocation)
    {{ model.name }}Policy() = default;

    {% if model.needs_jsengine %}
    // Destructor: Clean up JSEngine session if initialized (RAII pattern)
    ~{{ model.name }}Policy() {
        if (sessionId_.has_value()) {
            auto& jsEngine = ::RSM::JSEngine::instance();
            jsEngine.destroySession(sessionId_.value());
        }
    }

    // Prevent copy/move to maintain session ownership
    {{ model.name }}Policy(const {{ model.name }}Policy&) = delete;
    {{ model.name }}Policy& operator=(const {{ model.name }}Policy&) = delete;
    {{ model.name }}Policy({{ model.name }}Policy&&) = delete;
    {{ model.name }}Policy& operator=({{ model.name }}Policy&&) = delete;
    {% endif %}

    static State initialState() {
        return State::{{ model.initial | capitalize }};
    }

    static bool isFinalState(State state) {
        switch (state) {
            {% for state_id, state in model.states.items() %}
            {% if state.is_final %}
            case State::{{ state_id | capitalize }}:
                return true;
            {% endif %}
            {% endfor %}
            default:
                return false;
        }
    }

    // W3C SCXML 3.3: Parent state mapping (for HierarchicalStateHelper)
    static std::optional<State> getParent(State state) {
        switch (state) {
            {% for state_id, state in model.states.items() %}
            {% if state.parent %}
            case State::{{ state_id | capitalize }}:
                return State::{{ state.parent | capitalize }};
            {% endif %}
            {% endfor %}
            default:
                return std::nullopt;  // Root state
        }
    }

    // W3C SCXML 3.3: Check if state is compound (has initial child)
    static bool isCompoundState(State state) {
        switch (state) {
            {% for state_id, state in model.states.items() %}
            {% if state.initial %}
            case State::{{ state_id | capitalize }}:
                return true;
            {% endif %}
            {% endfor %}
            default:
                return false;
        }
    }

    // W3C SCXML 3.3: Get initial child of compound state
    static State getInitialChild(State state) {
        switch (state) {
            {% for state_id, state in model.states.items() %}
            {% if state.initial %}
            case State::{{ state_id | capitalize }}:
                return State::{{ state.initial | capitalize }};
            {% endif %}
            {% endfor %}
            default:
                return state;  // Not compound or no initial child
        }
    }

{% if model.has_parallel_states %}
    // W3C SCXML 3.4: Check if state is a parallel state
    static bool isParallelState(State state) {
        switch (state) {
            {% for state_id, state in model.states.items() %}
            {% if state.is_parallel %}
            case State::{{ state_id | capitalize }}:
                return true;
            {% endif %}
            {% endfor %}
            default:
                return false;
        }
    }

    // W3C SCXML 3.4: Get child regions of a parallel state
    static ::std::vector<State> getParallelRegions(State state) {
        switch (state) {
            {% for parallel_id, regions in model.parallel_regions.items() %}
            case State::{{ parallel_id | capitalize }}:
                return { {% for region in regions %}State::{{ region | capitalize }}{{ ", " if not loop.last }}{% endfor %} };
            {% endfor %}
            default:
                return {};
        }
    }

    // W3C SCXML 3.4: Check if descendant is a descendant of ancestor
    // ARCHITECTURE.MD: Zero Duplication - delegates to HierarchicalStateHelper
    static bool isDescendantOf(State descendant, State ancestor) {
        return ::RSM::Common::HierarchicalStateHelper<{{ model.name }}Policy>::isDescendantOf(descendant, ancestor);
    }

    // W3C SCXML 3.13: Get document order for exit order tie-breaking
    static int getDocumentOrder(State state) {
        switch (state) {
            {% for state_id, state in model.states.items() %}
            case State::{{ state_id | capitalize }}:
                return {{ state.document_order }};
            {% endfor %}
            default:
                return 0;
        }
    }
{% endif %}

{% include 'entry_exit_actions.jinja2' %}

    {% include 'process_transition.jinja2' %}

public:
    {% if model.needs_jsengine or model.static_invokes %}
    {% include 'jsengine_helpers.jinja2' %}
    {% endif %}

    {% include 'utility_methods.jinja2' %}

private:
};

// User-facing state machine class
{% if model.has_parent_communication %}
template<typename ParentStateMachine>
{% endif %}
class {{ model.name }} : public ::RSM::Static::StaticExecutionEngine<{% if model.has_parent_communication %}{{ model.name }}Policy<ParentStateMachine>{% elif model.static_invokes %}{{ model.name }}Policy<{{ model.name }}>{% else %}{{ model.name }}Policy{% endif %}> {
public:
{% if model.has_parent_communication %}
    // W3C SCXML 6.2: Parent state machine pointer for #_parent support (Zero Overhead)
    explicit {{ model.name }}(ParentStateMachine* parent) { this->policy_.parent_ = parent; }
{% else %}
    {{ model.name }}() = default;
{% endif %}

    {% if model.has_invoke %}
    ~{{ model.name }}() {
        // W3C SCXML 6.4: Cleanup child state machines on destruction
    }
    {% endif %}
};

} // namespace RSM::Generated::{{ model.name }}
