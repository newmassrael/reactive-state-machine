{% if model.needs_jsengine %}
    // W3C SCXML 5.9: Safe guard evaluation with error.execution on failure
    // ARCHITECTURE.md: Zero Duplication - Wraps shared GuardHelper with AOT-specific error handling
    template<typename Engine>
    bool safeEvaluateGuard(::RSM::JSEngine& jsEngine, const std::string& sessionId,
                           const std::string& guardExpr, Engine& engine) const {
        try {
            LOG_DEBUG("AOT safeEvaluateGuard: Evaluating guard: '{}'", guardExpr);
            bool result = ::RSM::GuardHelper::evaluateGuard(jsEngine, sessionId, guardExpr);
            LOG_DEBUG("AOT safeEvaluateGuard: Guard '{}' evaluated to: {}", guardExpr, result);
            return result;
        } catch (const std::exception& e) {
            LOG_ERROR("W3C SCXML 5.9: Guard evaluation failed: '{}' - {}", guardExpr, e.what());
            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, "Guard evaluation failed"));
            return false;
        }
    }

    // Helper: Set param in JSEngine for static invoke (W3C SCXML 6.4)
    void setParamInJSEngine(const std::string& paramName, const std::string& paramExpr) {
        ensureJSEngine();
        auto& jsEngine = ::RSM::JSEngine::instance();
        auto valueResult = jsEngine.evaluateExpression(sessionId_.value(), paramExpr).get();
        if (::RSM::JSEngine::isSuccess(valueResult)) {
            jsEngine.setVariable(sessionId_.value(), paramName, valueResult.getInternalValue());
        } else {
            LOG_ERROR("Failed to evaluate param expression for {}: {}", paramName, paramExpr);
        }
    }
{% endif %}

    // Helper: Convert Event enum to string for _event.name (W3C SCXML 5.10)
    static std::string getEventName(Event event) {
        switch (event) {
            case Event::NONE: return "";
{% for event_name in model.events | sort %}
            case Event::{{ event_name | replace('.', '_') | capitalize }}: return "{{ event_name }}";
{% endfor %}
            default: return "";
        }
    }

{% if model.has_parallel_states or model.uses_in_predicate %}
    // Helper: Convert State enum to string for In() predicate (W3C SCXML 5.9.2)
    static std::string getStateName(State state) {
        switch (state) {
{% for state_id in model.states.keys() | sort %}
            case State::{{ state_id | capitalize }}: return "{{ state_id }}";
{% endfor %}
            default: return "";
        }
    }

    // W3C SCXML 5.9.2: Check if state is active (for In() predicate)
    // ARCHITECTURE.md Zero Duplication: Use InPredicateHelper (Single Source of Truth)
    // Thread-safe: called from JSEngine worker thread
    bool isStateActive(const std::string& stateId) const {
        ::std::lock_guard<::std::mutex> lock(activeStatesMutex_);
        
        // ARCHITECTURE.md: Delegate to InPredicateHelper for shared In() predicate logic
        bool result = ::RSM::InPredicateHelper::isStateActive(
            activeStates_,
            [](State s) { return getStateName(s); },
            stateId
        );
        
        LOG_TRACE("AOT isStateActive: '{}' {} in activeStates_ (size={})", 
                  stateId, result ? "found" : "not found", activeStates_.size());
        return result;
    }
{% endif %}

private:
{% if model.needs_event_type %}
    // Helper: Determine event type using shared EventTypeHelper (W3C SCXML 5.10.1)
    std::string getEventType(const std::string& eventName) {
        bool isExternal = nextEventIsExternal_;
        if (nextEventIsExternal_) {
            nextEventIsExternal_ = false;
        }
        return ::RSM::EventTypeHelper::classifyEventType(eventName, isExternal);
    }
{% endif %}

{% if model.needs_jsengine and (model.needs_event_name or model.needs_event_data) %}
    // Helper: Set _event variable in JSEngine (W3C SCXML 5.10)
    void setCurrentEventInJSEngine(const std::string& eventName, const std::string& eventData = "",
                                const std::string& eventType = "", const std::string& sendId = "",
                                const std::string& origin = "", const std::string& originType = "", 
                                const std::string& invokeId = "") {
        if (eventName.empty()) return;
        ensureJSEngine();
        std::string actualType = eventType.empty() ? this->getEventType(eventName) : eventType;
        LOG_DEBUG("AOT setCurrentEventInJSEngine: name='{}', data='{}', type='{}', sendId='{}', origin='{}', originType='{}', invokeId='{}'",
                  eventName, eventData, actualType, sendId, origin, originType, invokeId);
        // W3C SCXML 5.10: Wait for setCurrentEvent to complete before proceeding (synchronous)
        ::RSM::JSEngine::instance().setCurrentEvent(sessionId_.value(), eventName, eventData,
                                                    actualType, sendId, origin, originType, invokeId).get();
    }
{% endif %}

public:
    // Helper: Ensure JSEngine session is destroyed before stack unwinding
    // This prevents stack-use-after-return when JSEngine background thread
    // tries to call In() predicate callbacks after the state machine is destroyed
    void ensureJSEngineSessionDestroyed() const {
{% if model.needs_jsengine %}
        if (!jsEngineInitialized_) return;
        if (!sessionId_.has_value()) return;
        auto& jsEngine = ::RSM::JSEngine::instance();
{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML: Unregister state query callback before destroying session
        // This prevents stack-use-after-return when JSEngine tries to call callback
        // after state machine is destroyed
        jsEngine.setStateQueryCallback(nullptr, sessionId_.value());
{% endif %}
        jsEngine.destroySession(sessionId_.value());
        jsEngineInitialized_ = false;
{% endif %}
    }
