{#
    Entry/Exit Actions Template (Jinja2)

    Last Modified: 2025-10-24
    ARCHITECTURE.md Version: 2025-10-23

    ARCHITECTURE.md Compliance (Lines 311-491):
    - Zero Duplication: Uses shared Helper classes for all W3C SCXML semantics
    - Single Source of Truth: All logic delegated to Helper classes shared with Interpreter
    - Long-Term Correctness: No workarounds, complete W3C SCXML implementation

    Helper Classes Used:
    - DoneDataHelper: W3C SCXML 5.5/5.7 (donedata param/content evaluation)
    - ParallelCompletionHelper: W3C SCXML 3.4/3.7.1 (parallel state completion detection)
    - HistoryHelper: W3C SCXML 3.11 (history state recording)
    - AssignHelper: W3C SCXML 5.3/5.4 (location validation)

    Features Implemented:
    - W3C SCXML 3.4: Parallel state auto-entry (enter all child regions)
    - W3C SCXML 3.7.1: Parallel state done.state event generation
    - W3C SCXML 3.8: Onexit handlers with datamodel updates
    - W3C SCXML 3.9: Entry/exit action execution
    - W3C SCXML 6.4: Static invoke lifecycle management
#}

    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.has_parent_communication and not model.needs_event_scheduler and not model.has_parallel_states %}    static void executeEntryActions(State state, Engine& engine) {
{% else %}    void executeEntryActions(State state, Engine& engine) {
{% endif %}
        (void)engine;
{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 3.4/3.12.1: Add state to active configuration for parallel states and In() predicate
        LOG_DEBUG("AOT executeEntryActions: Adding state {} to activeStates", static_cast<int>(state));
        {
            ::std::lock_guard<::std::mutex> lock(activeStatesMutex_);
            activeStates_.push_back(state);
        }
{% endif %}
        switch (state) {
{% for state_id, state in model.states.items() %}
            case State::{{ state_id | capitalize }}:
{% if state.on_entry or state.static_invokes or (state.is_final and state.donedata) or (state.is_final and state.parent) %}
                {
{% if state.static_invokes %}
                // W3C SCXML 6.4: Defer invoke execution until macrostep end (ARCHITECTURE.md Zero Duplication)
{% for invoke_info in state.static_invokes %}
                // Defer invoke: {{ invoke_info.invoke_id }} ({{ invoke_info.src }})
                ::RSM::InvokeHelper::deferInvoke(pendingInvokes_,
                    PendingInvoke{"{{ invoke_info.invoke_id }}", State::{{ state_id | capitalize }}});
                LOG_DEBUG("Deferred invoke: {{ invoke_info.invoke_id }} in state {{ state_id }}");
{% endfor %}
{% endif %}
{% for action in state.on_entry %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
{% if state.initial_transition_actions %}
                // W3C SCXML 3.3.2: Execute <initial> transition executable content
                // This content executes AFTER parent onentry and BEFORE child state entry
{% for action in state.initial_transition_actions %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
{% endif %}
{% if state.is_final and state.donedata %}
                // W3C SCXML 5.5: Evaluate donedata for final state
                {
                    std::string eventData;
{% if state.donedata.params %}
                    // W3C SCXML 5.5: Evaluate <param> elements
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    std::vector<std::pair<std::string, std::string>> params = {
{% for param in state.donedata.params %}
                        {"{{ param.name }}", "{{ param.location if param.location else param.expr }}"}{{ "," if not loop.last }}
{% endfor %}
                    };

                    // W3C SCXML 5.7: "If the location expression does not denote a valid location in the data model..."
                    // Empty param location raises error.execution and prevents done.state event generation
                    bool success = ::RSM::DoneDataHelper::evaluateParams(
                        jsEngine,
                        sessionId_.value(),
                        params,
                        eventData,
                        [&engine](const std::string& msg) {
                            LOG_WARN("Donedata param evaluation failed: {}", msg);
                            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
                        }
                    );

                    // W3C SCXML 5.7: If structural error (empty location), skip done.state event
                    if (!success) {
                        LOG_DEBUG("Skipping done.state event due to structural donedata error");
                        break;
                    }
{% elif state.donedata.contentexpr %}
                    // W3C SCXML 5.5: Evaluate <content expr="..."/>
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    ::RSM::DoneDataHelper::evaluateContent(
                        jsEngine,
                        sessionId_.value(),
                        "{{ state.donedata.contentexpr }}",
                        eventData,
                        [&engine](const std::string& msg) {
                            LOG_WARN("Donedata content evaluation failed: {}", msg);
                            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
                        }
                    );
{% elif state.donedata.content %}
                    // W3C SCXML 5.5: Literal <content>
                    eventData = "{{ state.donedata.content | escape_cpp }}";
{% endif %}

                    LOG_DEBUG("Final state {{ state_id }} reached with event data: {}", eventData);
                }
{% endif %}
{% if state.is_final and state.parent %}
                // W3C SCXML 3.7: Generate done.state.{parentId} event for compound state completion
                {
                    LOG_DEBUG("Final state {{ state_id }} entered, generating done.state.{{ state.parent }}");
                    engine.raise(typename Engine::EventWithMetadata(Event::Done_state_{{ state.parent }}));
                }
{% if model.states[state.parent].parent and model.states[model.states[state.parent].parent].is_parallel %}
                // W3C SCXML 3.4: Check if parent's parent (parallel state) is complete
                // W3C SCXML 3.7.1: Generate done.state event when all regions reach final states
                // Uses ParallelCompletionHelper (Zero Duplication - shared with Interpreter)
                {
                    const auto parallelState = State::{{ model.states[state.parent].parent | capitalize }};
                    LOG_DEBUG("Checking parallel state {} completion after region {} final",
                             static_cast<int>(parallelState), "{{ state.parent }}");

                    // W3C SCXML 3.4: Use shared Helper (ARCHITECTURE.md Zero Duplication Principle)
                    if (::RSM::ParallelCompletionHelper::areAllRegionsInFinal<State, {{ model.name }}Policy>(
                            parallelState, activeStates_)) {
                        LOG_DEBUG("All regions of parallel state {} are complete, generating done.state event",
                                 static_cast<int>(parallelState));
                        engine.raise(typename Engine::EventWithMetadata(Event::Done_state_{{ model.states[state.parent].parent }}));
                    }
                }
{% endif %}
{% endif %}
                }
{% endif %}
                break;
{% endfor %}
            default:
                break;
        }
{% if model.has_parallel_states %}

        // W3C SCXML 3.4: If entering parallel state, enter all child regions and their initial children
        // This ensures parallel states behave like Interpreter (auto-enter all regions)
        if (isParallelState(state)) {
            LOG_DEBUG("AOT executeEntryActions: State {} is parallel, entering child regions", static_cast<int>(state));
            auto regions = getParallelRegions(state);
            for (const auto& region : regions) {
                LOG_DEBUG("AOT executeEntryActions: Entering parallel region {}", static_cast<int>(region));
                executeEntryActions(region, engine);

                // W3C SCXML 3.3: If region is compound, enter initial child
                if (isCompoundState(region)) {
                    State initialChild = getInitialChild(region);
                    if (initialChild != region) {
                        LOG_DEBUG("AOT executeEntryActions: Entering initial child {} of region {}",
                                 static_cast<int>(initialChild), static_cast<int>(region));
                        executeEntryActions(initialChild, engine);
                    }
                }
            }
        }

        // W3C SCXML 3.3: If entering compound state (non-parallel), enter initial child
        // This ensures compound states behave like Interpreter (auto-enter initial child)
        if (isCompoundState(state) && !isParallelState(state)) {
            State initialChild = getInitialChild(state);
            if (initialChild != state) {
                LOG_DEBUG("AOT executeEntryActions: State {} is compound, entering initial child {}",
                         static_cast<int>(state), static_cast<int>(initialChild));
                executeEntryActions(initialChild, engine);
            }
        }
{% endif %}
    }

    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.needs_event_scheduler and not model.has_parallel_states %}    static void executeExitActions(State state, Engine& engine, const std::vector<State>& activeStatesBeforeTransition) {
{% else %}    void executeExitActions(State state, Engine& engine, const std::vector<State>& activeStatesBeforeTransition) {
{% endif %}
        (void)engine;
        (void)activeStatesBeforeTransition;  // May be unused if no history states

{% if model.has_parallel_states %}
        // W3C SCXML 3.4 + 3.13: Parallel state exit order
        // Matches Interpreter's exitParallelStateAndDescendants() logic
        LOG_DEBUG("AOT executeExitActions: Checking if state {} is parallel", static_cast<int>(state));
        if (isParallelState(state)) {
            LOG_DEBUG("AOT executeExitActions: State {} IS parallel, collecting active descendants", static_cast<int>(state));

            // W3C SCXML 3.4: Collect all active descendants of this parallel state
            // Matches Interpreter's collectDescendantStates() - exit ALL active descendants, not just direct regions
            ::std::vector<State> descendantsToExit;
            for (State activeState : activeStates_) {
                if (activeState != state && isDescendantOf(activeState, state)) {
                    descendantsToExit.push_back(activeState);
                    LOG_DEBUG("AOT executeExitActions: Found active descendant {} of parallel state {}",
                             static_cast<int>(activeState), static_cast<int>(state));
                }
            }

            LOG_DEBUG("AOT executeExitActions: Found {} active descendants to exit", descendantsToExit.size());

            // W3C SCXML 3.13: Sort descendants by reverse document order (deepest states exit first)
            ::std::sort(descendantsToExit.begin(), descendantsToExit.end(),
                       [](State a, State b) {
                           return getDocumentOrder(a) > getDocumentOrder(b);
                       });

            // Exit each active descendant (deepest first)
            for (State descendant : descendantsToExit) {
                LOG_DEBUG("AOT executeExitActions: Exiting active descendant {}", static_cast<int>(descendant));
                executeExitActions(descendant, engine, activeStatesBeforeTransition);
            }

            LOG_DEBUG("AOT executeExitActions: All active descendants exited, now exiting parallel state {} itself", static_cast<int>(state));
            // After exiting all descendants, fall through to exit parallel state itself
        } else {
            LOG_DEBUG("AOT executeExitActions: State {} is NOT parallel, proceeding to switch", static_cast<int>(state));
        }
{% endif %}
{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 3.4/3.12.1: Remove state from active configuration (parallel states and In() predicate)
        LOG_DEBUG("AOT executeExitActions: Removing state {} from activeStates", static_cast<int>(state));
        {
            ::std::lock_guard<::std::mutex> lock(activeStatesMutex_);
            activeStates_.erase(
                std::remove(activeStates_.begin(), activeStates_.end(), state),
                activeStates_.end()
            );
        }
{% endif %}
        {% if model.history_states %}
        // W3C SCXML 3.11: Record history before exiting compound states (matches Interpreter logic)
        // Use pre-transition active states (captured before processTransition modified currentState_)
        const std::vector<State>& activeStates = activeStatesBeforeTransition;
        
        {% for history_id, history_info in model.history_states.items() %}
        if (state == State::{{ history_info.parent | capitalize }}) {
            // W3C SCXML 3.11: Filter states using HistoryHelper (shared with Interpreter)
            auto filteredStates = ::RSM::HistoryHelper::recordHistory(
                activeStates,
                State::{{ history_info.parent | capitalize }},
                HistoryType::{{ history_info.type.upper() }},
                [](State s) { return {{ model.name }}Policy::getParent(s); }
            );
            
            // W3C SCXML 3.11: Record even if empty (valid scenario - state was active with no children)
            history_{{ history_id }} = filteredStates;
            LOG_DEBUG("Recorded {{ history_info.type }} history for {{ history_id }}: {} states", filteredStates.size());
        }
        {% endfor %}
        {% endif %}
        LOG_DEBUG("AOT executeExitActions: Entering switch for state {}", static_cast<int>(state));
        switch (state) {
{% for state_id, state in model.states.items() %}
            case State::{{ state_id | capitalize }}:
                LOG_DEBUG("AOT executeExitActions: Processing exit actions for state {} ({{ state_id }})", static_cast<int>(state));
                LOG_DEBUG("AOT executeExitActions: About to execute exit action block for state {}", static_cast<int>(state));
{% if state.on_exit or state.static_invokes %}
                {
{% if state.static_invokes %}
                // W3C SCXML 6.4: Cancel pending invokes for exited state (ARCHITECTURE.md Zero Duplication)
                ::RSM::InvokeHelper::cancelInvokesForState(pendingInvokes_, state);
                {% for invoke_info in state.static_invokes %}

                // W3C SCXML 6.4: Cleanup already-running static invoke child (if started in previous macrostep)
                if (child_{{ invoke_info.invoke_id }}_) {
                    LOG_DEBUG("Stopping static invoke: id={{ invoke_info.invoke_id }}");
                    // W3C SCXML 6.4: Send cancel.invoke platform event
                    engine.raise(typename Engine::EventWithMetadata(Event::Cancel_invoke));
                    child_{{ invoke_info.invoke_id }}_.reset();  // Destroy child state machine
                }
                activeInvokes_.erase("{{ invoke_info.invoke_id }}");
{% endfor %}
{% endif %}
{% for action in state.on_exit %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
                }
{% endif %}
                break;
{% endfor %}
            default:
                break;
        }
    }

{% if model.static_invokes %}

    // W3C SCXML 6.4: Execute pending invokes at macrostep end
    // Uses InvokeHelper defer/cancel/execute pattern (ARCHITECTURE.md Zero Duplication)
    template<typename Engine>
    void executePendingInvokes(Engine& engine) {
        (void)engine;  // May be used in future for context
        
        if (pendingInvokes_.empty()) {
            return;
        }
        
        LOG_DEBUG("Executing {} pending invokes at macrostep end", pendingInvokes_.size());
        
        // W3C SCXML 6.4: Use InvokeHelper as Single Source of Truth
        ::RSM::InvokeHelper::executePendingInvokes(
            pendingInvokes_,
            [this](const PendingInvoke& pending) {
                LOG_DEBUG("Executing pending invoke: {} in state {}", pending.invokeId, static_cast<int>(pending.state));
                
                // Switch on state to find which invoke to execute
                {% for state_id, state in model.states.items() %}
                {% if state.static_invokes %}
                if (pending.state == State::{{ state_id | capitalize }}) {
                    {% for invoke_info in state.static_invokes %}
                    if (pending.invokeId == "{{ invoke_info.invoke_id }}") {
                        // W3C SCXML 6.4: Instantiate and initialize child state machine
                        LOG_DEBUG("Creating child state machine: {{ invoke_info.child_name }} for invoke {{ invoke_info.invoke_id }}");
                        
                        // Create child instance with parent pointer and invokeId
                        child_{{ invoke_info.invoke_id }}_ = std::make_shared<::RSM::Generated::{{ invoke_info.child_name }}::{{ invoke_info.child_name }}<SelfType>>(self_, "{{ invoke_info.invoke_id }}");

                        {% if invoke_info.idlocation %}
                        // W3C SCXML 6.4.1: Store invokeId in parent datamodel via idlocation
                        {
                            ensureJSEngine();
                            auto& jsEngine = ::RSM::JSEngine::instance();
                            jsEngine.setVariable(sessionId_.value(), "{{ invoke_info.idlocation }}", "{{ invoke_info.invoke_id }}").get();
                            LOG_DEBUG("Set idlocation {{ invoke_info.idlocation }} = {{ invoke_info.invoke_id }}");
                        }
                        {% endif %}

                        {% if invoke_info.params %}
                        // W3C SCXML 6.4.1: Pass params to child datamodel before initialization
                        {% for param in invoke_info.params %}
                        {% if invoke_info.child_needs_jsengine %}
                        child_{{ invoke_info.invoke_id }}_->setParamInJSEngine("{{ param.name }}", "{{ param.expr }}");
                        {% else %}
                        // Child does not use JSEngine - params handled via static datamodel
                        LOG_DEBUG("Param {{ param.name }}={{ param.expr }} - child uses static datamodel");
                        {% endif %}
                        {% endfor %}
                        {% endif %}

                        // W3C SCXML 6.4: Initialize child state machine
                        child_{{ invoke_info.invoke_id }}_->initialize();
                        
                        // W3C SCXML 6.4: Register completion callback for done.invoke event
                        child_{{ invoke_info.invoke_id }}_->setCompletionCallback([this]() {
                            // W3C SCXML 6.4: Mark done.invoke as pending
                            pendingDoneInvoke_{{ invoke_info.invoke_id }}_ = true;
                            LOG_DEBUG("Child state machine {{ invoke_info.invoke_id }} completed, done.invoke pending");
                        });
                        
                        // W3C SCXML 6.4: Track active invoke session
                        activeInvokes_["{{ invoke_info.invoke_id }}"] = ChildSession{
                            sessionId_.has_value() ? sessionId_.value() : "",  // Parent session ID
                            "{{ invoke_info.invoke_id }}",
                            sessionId_.has_value() ? sessionId_.value() : "",  // Parent session ID (same)
                            false,  // autoforward
                            ""      // finalize
                        };
                        
                        LOG_DEBUG("Child state machine {{ invoke_info.invoke_id }} initialized and running");
                        return;  // Found and executed the invoke
                    }
                    {% endfor %}
                }
                {% endif %}
                {% endfor %}
                
                LOG_ERROR("Pending invoke not found: {} in state {}", pending.invokeId, static_cast<int>(pending.state));
            }
        );
        
        LOG_DEBUG("All pending invokes executed");
    }
{% endif %}
