{#
    Entry/Exit Actions Template (Jinja2)

    Last Modified: 2025-10-24
    ARCHITECTURE.md Version: 2025-10-23

    ARCHITECTURE.md Compliance (Lines 311-491):
    - Zero Duplication: Uses shared Helper classes for all W3C SCXML semantics
    - Single Source of Truth: All logic delegated to Helper classes shared with Interpreter
    - Long-Term Correctness: No workarounds, complete W3C SCXML implementation

    Helper Classes Used:
    - DoneDataHelper: W3C SCXML 5.5/5.7 (donedata param/content evaluation)
    - ParallelCompletionHelper: W3C SCXML 3.4/3.7.1 (parallel state completion detection)
    - HistoryHelper: W3C SCXML 3.11 (history state recording)
    - AssignHelper: W3C SCXML 5.3/5.4 (location validation)

    Features Implemented:
    - W3C SCXML 3.4: Parallel state auto-entry (enter all child regions)
    - W3C SCXML 3.7.1: Parallel state done.state event generation
    - W3C SCXML 3.8: Onexit handlers with datamodel updates
    - W3C SCXML 3.9: Entry/exit action execution
    - W3C SCXML 6.4: Static invoke lifecycle management
#}

    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.has_parent_communication and not model.needs_event_scheduler and not model.has_parallel_states %}    static void executeEntryActions(State state, Engine& engine) {
{% else %}    void executeEntryActions(State state, Engine& engine) {
{% endif %}
        (void)engine;
{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 3.4/3.12.1: Add state to active configuration for parallel states and In() predicate
        LOG_DEBUG("AOT executeEntryActions: Adding state {} to activeStates", static_cast<int>(state));
        {
            ::std::lock_guard<::std::mutex> lock(activeStatesMutex_);
            activeStates_.push_back(state);
        }
{% endif %}
        switch (state) {
{% for state_id, state in model.states.items() %}
            case State::{{ state_id | capitalize }}:
{% if state.on_entry or state.static_invokes or (state.is_final and state.donedata) or (state.is_final and state.parent) %}
                {
{% if state.static_invokes %}
                // W3C SCXML 6.4: Start invoke elements
                ensureSessionId();
                if (!sessionId_.has_value()) return;  // Should not happen

{% for invoke_info in state.static_invokes %}
                // W3C SCXML 6.4: Static invoke (compile-time child SCXML)
                // Child SCXML: {{ invoke_info.src }} (generated as {{ invoke_info.child_name }}_sm.h)
                {
                    std::string childSessionId = sessionId_.value() + "_" + "{{ invoke_info.invoke_id }}";
                    LOG_INFO("Starting static invoke: id={{ invoke_info.invoke_id }}, src={{ invoke_info.src }}");

{% if invoke_info.idlocation %}
                    // W3C SCXML 6.4.1: Set idlocation variable to invoke id (before child initialization)
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    jsEngine.setVariable(sessionId_.value(), "{{ invoke_info.idlocation }}", "{{ invoke_info.invoke_id }}");
{% endif %}

                    // Instantiate and store child state machine in Policy member
                    child_{{ invoke_info.invoke_id }}_ = std::make_shared<::RSM::Generated::{{ invoke_info.child_name }}::{{ invoke_info.child_name }}<SelfType>>(static_cast<SelfType*>(&engine));
                    
                    // W3C SCXML 6.4.1: Set child's invokeid for _event.invokeid in parent (test338)
                    child_{{ invoke_info.invoke_id }}_->getPolicy().invokeId_ = "{{ invoke_info.invoke_id }}";

                    // W3C SCXML 6.4: Set completion callback for done.invoke event
                    child_{{ invoke_info.invoke_id }}_->setCompletionCallback([this]() {
                        pendingDoneInvoke_{{ invoke_info.invoke_id }}_ = true;
                        LOG_DEBUG("Child {{ invoke_info.invoke_id }} completed, pending done.invoke event");
                    });

                    // W3C SCXML 6.4.6: Handle invoke failure with error.execution
                    try {
{% if invoke_info.params %}
                        // W3C SCXML 6.4: Pass params to child state machine (before initialization for eventless transitions)
{% for param in invoke_info.params %}
{% if invoke_info.child_needs_jsengine %}
                        // Child uses JSEngine - initialize JSEngine first, then override param
                        child_{{ invoke_info.invoke_id }}_->getPolicy().ensureJSEngine();
                        auto& childJSEngine = ::RSM::JSEngine::instance();
                        auto childSessionId = child_{{ invoke_info.invoke_id }}_->getPolicy().sessionId_.value();
                        // Override param value BEFORE initialize() processes eventless transitions
                        childJSEngine.setVariable(childSessionId, "{{ param.name }}", {{ param.expr }});
{% else %}
                        // Child uses pure static datamodel - set C++ member variable before initialize()
                        child_{{ invoke_info.invoke_id }}_->getPolicy().{{ param.name }} = {{ param.expr }};
{% endif %}
{% endfor %}

{% endif %}
                        child_{{ invoke_info.invoke_id }}_->initialize();

                        // W3C SCXML 6.4: Check if child immediately reached final state
                        if (child_{{ invoke_info.invoke_id }}_->isInFinalState()) {
                            LOG_INFO("Child {{ invoke_info.invoke_id }} immediately completed, raising done.invoke");
                            engine.raise(typename Engine::EventWithMetadata(Event::Done_invoke));
                        }
                    } catch (const std::exception& e) {
                        // W3C SCXML 6.4.6: Raise error.execution on invoke failure
                        LOG_ERROR("Failed to initialize child {{ invoke_info.invoke_id }}: {}", e.what());
                        engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, e.what()));
                        child_{{ invoke_info.invoke_id }}_ = nullptr;
                    }

                    // W3C SCXML 6.4: Track child session for lifecycle management
                    ChildSession session;
                    session.sessionId = childSessionId;
                    session.invokeId = "{{ invoke_info.invoke_id }}";
                    session.parentSessionId = sessionId_.value();
                    session.autoforward = {{ 'true' if invoke_info.autoforward else 'false' }};
                    session.finalizeScript = "";

                    activeInvokes_["{{ invoke_info.invoke_id }}"] = session;
                    LOG_DEBUG("Invoke session created: id={}, autoforward={}", "{{ invoke_info.invoke_id }}", session.autoforward);
                }
{% endfor %}
{% endif %}
{% for action in state.on_entry %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
{% if state.initial_transition_actions %}
                // W3C SCXML 3.3.2: Execute <initial> transition executable content
                // This content executes AFTER parent onentry and BEFORE child state entry
{% for action in state.initial_transition_actions %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
{% endif %}
{% if state.is_final and state.donedata %}
                // W3C SCXML 5.5: Evaluate donedata for final state
                {
                    std::string eventData;
{% if state.donedata.params %}
                    // W3C SCXML 5.5: Evaluate <param> elements
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    std::vector<std::pair<std::string, std::string>> params = {
{% for param in state.donedata.params %}
                        {"{{ param.name }}", "{{ param.location if param.location else param.expr }}"}{{ "," if not loop.last }}
{% endfor %}
                    };

                    // W3C SCXML 5.7: "If the location expression does not denote a valid location in the data model..."
                    // Empty param location raises error.execution and prevents done.state event generation
                    bool success = ::RSM::DoneDataHelper::evaluateParams(
                        jsEngine,
                        sessionId_.value(),
                        params,
                        eventData,
                        [&engine](const std::string& msg) {
                            LOG_WARN("Donedata param evaluation failed: {}", msg);
                            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
                        }
                    );

                    // W3C SCXML 5.7: If structural error (empty location), skip done.state event
                    if (!success) {
                        LOG_DEBUG("Skipping done.state event due to structural donedata error");
                        break;
                    }
{% elif state.donedata.contentexpr %}
                    // W3C SCXML 5.5: Evaluate <content expr="..."/>
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    ::RSM::DoneDataHelper::evaluateContent(
                        jsEngine,
                        sessionId_.value(),
                        "{{ state.donedata.contentexpr }}",
                        eventData,
                        [&engine](const std::string& msg) {
                            LOG_WARN("Donedata content evaluation failed: {}", msg);
                            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
                        }
                    );
{% elif state.donedata.content %}
                    // W3C SCXML 5.5: Literal <content>
                    eventData = "{{ state.donedata.content | escape_cpp }}";
{% endif %}

                    LOG_DEBUG("Final state {{ state_id }} reached with event data: {}", eventData);
                }
{% endif %}
{% if state.is_final and state.parent %}
                // W3C SCXML 3.7: Generate done.state.{parentId} event for compound state completion
                {
                    LOG_DEBUG("Final state {{ state_id }} entered, generating done.state.{{ state.parent }}");
                    engine.raise(typename Engine::EventWithMetadata(Event::Done_state_{{ state.parent }}));
                }
{% if model.states[state.parent].parent and model.states[model.states[state.parent].parent].is_parallel %}
                // W3C SCXML 3.4: Check if parent's parent (parallel state) is complete
                // W3C SCXML 3.7.1: Generate done.state event when all regions reach final states
                // Uses ParallelCompletionHelper (Zero Duplication - shared with Interpreter)
                {
                    const auto parallelState = State::{{ model.states[state.parent].parent | capitalize }};
                    LOG_DEBUG("Checking parallel state {} completion after region {} final",
                             static_cast<int>(parallelState), "{{ state.parent }}");

                    // W3C SCXML 3.4: Use shared Helper (ARCHITECTURE.md Zero Duplication Principle)
                    if (::RSM::ParallelCompletionHelper::areAllRegionsInFinal<State, {{ model.name }}Policy>(
                            parallelState, activeStates_)) {
                        LOG_DEBUG("All regions of parallel state {} are complete, generating done.state event",
                                 static_cast<int>(parallelState));
                        engine.raise(typename Engine::EventWithMetadata(Event::Done_state_{{ model.states[state.parent].parent }}));
                    }
                }
{% endif %}
{% endif %}
                }
{% endif %}
                break;
{% endfor %}
            default:
                break;
        }
{% if model.has_parallel_states %}

        // W3C SCXML 3.4: If entering parallel state, enter all child regions and their initial children
        // This ensures parallel states behave like Interpreter (auto-enter all regions)
        if (isParallelState(state)) {
            LOG_DEBUG("AOT executeEntryActions: State {} is parallel, entering child regions", static_cast<int>(state));
            auto regions = getParallelRegions(state);
            for (const auto& region : regions) {
                LOG_DEBUG("AOT executeEntryActions: Entering parallel region {}", static_cast<int>(region));
                executeEntryActions(region, engine);

                // W3C SCXML 3.3: If region is compound, enter initial child
                if (isCompoundState(region)) {
                    State initialChild = getInitialChild(region);
                    if (initialChild != region) {
                        LOG_DEBUG("AOT executeEntryActions: Entering initial child {} of region {}",
                                 static_cast<int>(initialChild), static_cast<int>(region));
                        executeEntryActions(initialChild, engine);
                    }
                }
            }
        }

        // W3C SCXML 3.3: If entering compound state (non-parallel), enter initial child
        // This ensures compound states behave like Interpreter (auto-enter initial child)
        if (isCompoundState(state) && !isParallelState(state)) {
            State initialChild = getInitialChild(state);
            if (initialChild != state) {
                LOG_DEBUG("AOT executeEntryActions: State {} is compound, entering initial child {}",
                         static_cast<int>(state), static_cast<int>(initialChild));
                executeEntryActions(initialChild, engine);
            }
        }
{% endif %}
    }

    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.needs_event_scheduler and not model.has_parallel_states %}    static void executeExitActions(State state, Engine& engine, const std::vector<State>& activeStatesBeforeTransition) {
{% else %}    void executeExitActions(State state, Engine& engine, const std::vector<State>& activeStatesBeforeTransition) {
{% endif %}
        (void)engine;
        (void)activeStatesBeforeTransition;  // May be unused if no history states

{% if model.has_parallel_states %}
        // W3C SCXML 3.4 + 3.13: Parallel state exit order
        // Matches Interpreter's exitParallelStateAndDescendants() logic
        LOG_DEBUG("AOT executeExitActions: Checking if state {} is parallel", static_cast<int>(state));
        if (isParallelState(state)) {
            LOG_DEBUG("AOT executeExitActions: State {} IS parallel, collecting active descendants", static_cast<int>(state));

            // W3C SCXML 3.4: Collect all active descendants of this parallel state
            // Matches Interpreter's collectDescendantStates() - exit ALL active descendants, not just direct regions
            ::std::vector<State> descendantsToExit;
            for (State activeState : activeStates_) {
                if (activeState != state && isDescendantOf(activeState, state)) {
                    descendantsToExit.push_back(activeState);
                    LOG_DEBUG("AOT executeExitActions: Found active descendant {} of parallel state {}",
                             static_cast<int>(activeState), static_cast<int>(state));
                }
            }

            LOG_DEBUG("AOT executeExitActions: Found {} active descendants to exit", descendantsToExit.size());

            // W3C SCXML 3.13: Sort descendants by reverse document order (deepest states exit first)
            ::std::sort(descendantsToExit.begin(), descendantsToExit.end(),
                       [](State a, State b) {
                           return getDocumentOrder(a) > getDocumentOrder(b);
                       });

            // Exit each active descendant (deepest first)
            for (State descendant : descendantsToExit) {
                LOG_DEBUG("AOT executeExitActions: Exiting active descendant {}", static_cast<int>(descendant));
                executeExitActions(descendant, engine, activeStatesBeforeTransition);
            }

            LOG_DEBUG("AOT executeExitActions: All active descendants exited, now exiting parallel state {} itself", static_cast<int>(state));
            // After exiting all descendants, fall through to exit parallel state itself
        } else {
            LOG_DEBUG("AOT executeExitActions: State {} is NOT parallel, proceeding to switch", static_cast<int>(state));
        }
{% endif %}
{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 3.4/3.12.1: Remove state from active configuration (parallel states and In() predicate)
        LOG_DEBUG("AOT executeExitActions: Removing state {} from activeStates", static_cast<int>(state));
        {
            ::std::lock_guard<::std::mutex> lock(activeStatesMutex_);
            activeStates_.erase(
                std::remove(activeStates_.begin(), activeStates_.end(), state),
                activeStates_.end()
            );
        }
{% endif %}
        {% if model.history_states %}
        // W3C SCXML 3.11: Record history before exiting compound states (matches Interpreter logic)
        // Use pre-transition active states (captured before processTransition modified currentState_)
        const std::vector<State>& activeStates = activeStatesBeforeTransition;
        
        {% for history_id, history_info in model.history_states.items() %}
        if (state == State::{{ history_info.parent | capitalize }}) {
            // W3C SCXML 3.11: Filter states using HistoryHelper (shared with Interpreter)
            auto filteredStates = ::RSM::HistoryHelper::recordHistory(
                activeStates,
                State::{{ history_info.parent | capitalize }},
                HistoryType::{{ history_info.type.upper() }},
                [](State s) { return {{ model.name }}Policy::getParent(s); }
            );
            
            // W3C SCXML 3.11: Record even if empty (valid scenario - state was active with no children)
            history_{{ history_id }} = filteredStates;
            LOG_DEBUG("Recorded {{ history_info.type }} history for {{ history_id }}: {} states", filteredStates.size());
        }
        {% endfor %}
        {% endif %}
        LOG_DEBUG("AOT executeExitActions: Entering switch for state {}", static_cast<int>(state));
        switch (state) {
{% for state_id, state in model.states.items() %}
            case State::{{ state_id | capitalize }}:
                LOG_DEBUG("AOT executeExitActions: Processing exit actions for state {} ({{ state_id }})", static_cast<int>(state));
                LOG_DEBUG("AOT executeExitActions: About to execute exit action block for state {}", static_cast<int>(state));
{% if state.on_exit or state.static_invokes %}
                {
{% if state.static_invokes %}
                // W3C SCXML 6.4: Cancel invoke elements
                {% for invoke_info in state.static_invokes %}

                // W3C SCXML 6.4: Cleanup static invoke child
                if (child_{{ invoke_info.invoke_id }}_) {
                    LOG_DEBUG("Stopping static invoke: id={{ invoke_info.invoke_id }}");
                    // W3C SCXML 6.4: Send cancel.invoke platform event
                    engine.raise(typename Engine::EventWithMetadata(Event::Cancel_invoke));
                    child_{{ invoke_info.invoke_id }}_.reset();  // Destroy child state machine
                }
                activeInvokes_.erase("{{ invoke_info.invoke_id }}");
{% endfor %}
{% endif %}
{% for action in state.on_exit %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
                }
{% endif %}
                break;
{% endfor %}
            default:
                break;
        }
    }
