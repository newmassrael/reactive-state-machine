{#
    Entry/Exit Actions Template (Jinja2)

    ARCHITECTURE.md Compliance:
    - Zero Duplication: Uses DoneDataHelper for param/content evaluation
    - Single Source of Truth: All W3C SCXML 5.5/5.7 logic in helper class
    - Long-Term Correctness: No workarounds, complete implementation
#}

    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.has_parent_communication and not model.needs_event_scheduler %}    static void executeEntryActions(State state, Engine& engine) {
{% else %}    void executeEntryActions(State state, Engine& engine) {
{% endif %}
        (void)engine;
        switch (state) {
{% for state_id, state in model.states.items() %}
            case State::{{ state_id | capitalize }}:
{% if state.on_entry or state.static_invokes or (state.is_final and state.donedata) %}
                {
{% if state.static_invokes %}
                // W3C SCXML 6.4: Start invoke elements
                ensureSessionId();
                if (!sessionId_.has_value()) return;  // Should not happen

{% for invoke_info in state.static_invokes %}
                // W3C SCXML 6.4: Static invoke (compile-time child SCXML)
                // Child SCXML: {{ invoke_info.src }} (generated as {{ invoke_info.child_name }}_sm.h)
                {
                    std::string childSessionId = sessionId_.value() + "_" + "{{ invoke_info.invoke_id }}";
                    LOG_INFO("Starting static invoke: id={{ invoke_info.invoke_id }}, src={{ invoke_info.src }}");

{% if invoke_info.idlocation %}
                    // W3C SCXML 6.4.1: Set idlocation variable to invoke id (before child initialization)
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    jsEngine.setVariable(sessionId_.value(), "{{ invoke_info.idlocation }}", "{{ invoke_info.invoke_id }}");
{% endif %}

                    // Instantiate and store child state machine in Policy member
                    child_{{ invoke_info.invoke_id }}_ = std::make_shared<::RSM::Generated::{{ invoke_info.child_name }}::{{ invoke_info.child_name }}<SelfType>>(static_cast<SelfType*>(&engine));
                    
                    // W3C SCXML 6.4.1: Set child's invokeid for _event.invokeid in parent (test338)
                    child_{{ invoke_info.invoke_id }}_->getPolicy().invokeId_ = "{{ invoke_info.invoke_id }}";

                    // W3C SCXML 6.4: Set completion callback for done.invoke event
                    child_{{ invoke_info.invoke_id }}_->setCompletionCallback([this]() {
                        pendingDoneInvoke_{{ invoke_info.invoke_id }}_ = true;
                        LOG_DEBUG("Child {{ invoke_info.invoke_id }} completed, pending done.invoke event");
                    });

                    // W3C SCXML 6.4.6: Handle invoke failure with error.execution
                    try {
{% if invoke_info.params %}
                        // W3C SCXML 6.4: Pass params to child state machine (before initialization for eventless transitions)
{% for param in invoke_info.params %}
{% if invoke_info.child_needs_jsengine %}
                        // Child uses JSEngine - initialize JSEngine first, then override param
                        child_{{ invoke_info.invoke_id }}_->getPolicy().ensureJSEngine();
                        auto& childJSEngine = ::RSM::JSEngine::instance();
                        auto childSessionId = child_{{ invoke_info.invoke_id }}_->getPolicy().sessionId_.value();
                        // Override param value BEFORE initialize() processes eventless transitions
                        childJSEngine.setVariable(childSessionId, "{{ param.name }}", {{ param.expr }});
{% else %}
                        // Child uses pure static datamodel - set C++ member variable before initialize()
                        child_{{ invoke_info.invoke_id }}_->getPolicy().{{ param.name }} = {{ param.expr }};
{% endif %}
{% endfor %}

{% endif %}
                        child_{{ invoke_info.invoke_id }}_->initialize();

                        // W3C SCXML 6.4: Check if child immediately reached final state
                        if (child_{{ invoke_info.invoke_id }}_->isInFinalState()) {
                            LOG_INFO("Child {{ invoke_info.invoke_id }} immediately completed, raising done.invoke");
                            engine.raise(typename Engine::EventWithMetadata(Event::Done_invoke));
                        }
                    } catch (const std::exception& e) {
                        // W3C SCXML 6.4.6: Raise error.execution on invoke failure
                        LOG_ERROR("Failed to initialize child {{ invoke_info.invoke_id }}: {}", e.what());
                        engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, e.what()));
                        child_{{ invoke_info.invoke_id }}_ = nullptr;
                    }

                    // W3C SCXML 6.4: Track child session for lifecycle management
                    ChildSession session;
                    session.sessionId = childSessionId;
                    session.invokeId = "{{ invoke_info.invoke_id }}";
                    session.parentSessionId = sessionId_.value();
                    session.autoforward = {{ 'true' if invoke_info.autoforward else 'false' }};
                    session.finalizeScript = "";

                    activeInvokes_["{{ invoke_info.invoke_id }}"] = session;
                    LOG_DEBUG("Invoke session created: id={}, autoforward={}", "{{ invoke_info.invoke_id }}", session.autoforward);
                }
{% endfor %}
{% endif %}
{% for action in state.on_entry %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
{% if state.is_final and state.donedata %}
                // W3C SCXML 5.5: Evaluate donedata for final state
                {
                    std::string eventData;
{% if state.donedata.params %}
                    // W3C SCXML 5.5: Evaluate <param> elements
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    std::vector<std::pair<std::string, std::string>> params = {
{% for param in state.donedata.params %}
                        {"{{ param.name }}", "{{ param.location if param.location else param.expr }}"}{{ "," if not loop.last }}
{% endfor %}
                    };

                    // W3C SCXML 5.7: "If the location expression does not denote a valid location in the data model..."
                    // Empty param location raises error.execution and prevents done.state event generation
                    bool success = ::RSM::DoneDataHelper::evaluateParams(
                        jsEngine,
                        sessionId_.value(),
                        params,
                        eventData,
                        [&engine](const std::string& msg) {
                            LOG_WARN("Donedata param evaluation failed: {}", msg);
                            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
                        }
                    );

                    // W3C SCXML 5.7: If structural error (empty location), skip done.state event
                    if (!success) {
                        LOG_DEBUG("Skipping done.state event due to structural donedata error");
                        break;
                    }
{% elif state.donedata.contentexpr %}
                    // W3C SCXML 5.5: Evaluate <content expr="..."/>
                    this->ensureJSEngine();
                    auto& jsEngine = ::RSM::JSEngine::instance();
                    ::RSM::DoneDataHelper::evaluateContent(
                        jsEngine,
                        sessionId_.value(),
                        "{{ state.donedata.contentexpr }}",
                        eventData,
                        [&engine](const std::string& msg) {
                            LOG_WARN("Donedata content evaluation failed: {}", msg);
                            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
                        }
                    );
{% elif state.donedata.content %}
                    // W3C SCXML 5.5: Literal <content>
                    eventData = "{{ state.donedata.content | escape_cpp }}";
{% endif %}

                    LOG_DEBUG("Final state {{ state_id }} reached with event data: {}", eventData);
                }
{% endif %}
{% if state.is_final and state.parent %}
                // W3C SCXML 3.7: Generate done.state.{parentId} event for compound state completion
                {
                    LOG_DEBUG("Final state {{ state_id }} entered, generating done.state.{{ state.parent }}");
                    engine.raise(typename Engine::EventWithMetadata(Event::Done_state_{{ state.parent }}));
                }
{% endif %}
                }
{% endif %}
                break;
{% endfor %}
            default:
                break;
        }
    }

    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.needs_event_scheduler %}    static void executeExitActions(State state, Engine& engine) {
{% else %}    void executeExitActions(State state, Engine& engine) {
{% endif %}
        (void)engine;
        switch (state) {
{% for state_id, state in model.states.items() %}
            case State::{{ state_id | capitalize }}:
{% if state.on_exit or state.static_invokes %}
                {
{% if state.static_invokes %}
                // W3C SCXML 6.4: Cancel invoke elements
                {% for invoke_info in state.static_invokes %}

                // W3C SCXML 6.4: Cleanup static invoke child
                if (child_{{ invoke_info.invoke_id }}_) {
                    LOG_DEBUG("Stopping static invoke: id={{ invoke_info.invoke_id }}");
                    // W3C SCXML 6.4: Send cancel.invoke platform event
                    engine.raise(typename Engine::EventWithMetadata(Event::Cancel_invoke));
                    child_{{ invoke_info.invoke_id }}_.reset();  // Destroy child state machine
                }
                activeInvokes_.erase("{{ invoke_info.invoke_id }}");
{% endfor %}
{% endif %}
{% for action in state.on_exit %}
                {% set in_entry_exit = true %}
                {% include 'actions/' + action.type + '.jinja2' %}

{% endfor %}
                }
{% endif %}
                break;
{% endfor %}
            default:
                break;
        }
    }
