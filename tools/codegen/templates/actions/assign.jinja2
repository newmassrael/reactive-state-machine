{
// W3C SCXML 5.3, 5.4: Validate assignment location using shared AssignHelper
if (::RSM::AssignHelper::isValidLocation("{{ action.location }}")) {
    // Location is valid, proceed with assignment
    LOG_DEBUG("AOT assign: Before ensureJSEngine for {{ action.location }}");
    this->ensureJSEngine();
    LOG_DEBUG("AOT assign: After ensureJSEngine, sessionId={}", sessionId_.value_or("NONE"));
    auto& jsEngine = ::RSM::JSEngine::instance();
    {
        // W3C SCXML 5.3: Execute assignment as JavaScript expression to preserve object references
        // Using direct assignment (location = expr) instead of getInternalValue() for reference semantics
        // Remove trailing semicolon from expr to avoid syntax error in parenthesized expression
        LOG_DEBUG("AOT assign: Evaluating: {{ action.location }} = ({{ action.expr.rstrip(';') }})");
        auto exprResult = jsEngine.evaluateExpression(sessionId_.value(), "{{ action.location }} = ({{ action.expr.rstrip(';') }})").get();
        LOG_DEBUG("AOT assign: Result - success={}", ::RSM::JSEngine::isSuccess(exprResult));
        if (!::RSM::JSEngine::isSuccess(exprResult)) {
            std::string errorMsg = "Failed to evaluate assignment expression: {{ action.location }} = ({{ action.expr.rstrip(';') }})";
            LOG_ERROR("{}", errorMsg);
            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, errorMsg));
        }
    }
} else {
    // W3C SCXML 5.3/5.4/B.2: Invalid or read-only location
    std::string errorMsg = ::RSM::AssignHelper::getInvalidLocationErrorMessage("{{ action.location }}");
    LOG_ERROR("W3C SCXML 5.3: {}", errorMsg);
    engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, errorMsg));
}
}
