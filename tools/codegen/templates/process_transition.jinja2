{#
    Process Transition Template (Jinja2)

    ARCHITECTURE.MD Compliance:
    - Zero Duplication: Matches Interpreter's hierarchical event processing logic
    - Single Source of Truth: Hierarchical transition checking from W3C SCXML 3.12
    - Long-Term Correctness: Complete Interpreter replication, no simplified workarounds
#}

{% macro restore_history_or_transition(transition) %}
{% if transition.history_target is defined %}
                    // W3C SCXML 3.11: Restore history or use default transition (matches Interpreter logic)
                    if (history_{{ transition.history_target }}.has_value()) {
                        // Restore from recorded history (may contain multiple states for parallel regions)
                        const auto& recordedStates = history_{{ transition.history_target }}.value();
                        if (!recordedStates.empty()) {
                            // For simple state machines (no parallel), restore first state
                            // For parallel state machines, engine will handle multiple states
                            currentState = recordedStates[0];
                            LOG_DEBUG("AOT processTransition: Restored history {} -> {} ({} states recorded)", 
                                     "{{ transition.history_target }}", static_cast<int>(currentState), recordedStates.size());
                        } else {
{% set history_info = model.history_states[transition.history_target] %}
{% set leaf_target = history_info.leaf_target %}
                            // W3C SCXML 3.11: Empty history was recorded (valid scenario) - use default transition
                            currentState = State::{{ leaf_target | capitalize }};
                            LOG_DEBUG("AOT processTransition: Empty history for {{ transition.history_target }}, using default transition -> {}", static_cast<int>(currentState));
                        }
                    } else {
{% set history_info = model.history_states[transition.history_target] %}
{% set leaf_target = history_info.leaf_target %}
                        // History never recorded - use default transition
                        currentState = State::{{ leaf_target | capitalize }};
                        LOG_DEBUG("AOT processTransition: No history recorded for {{ transition.history_target }}, using default transition -> {}", static_cast<int>(currentState));
                    }
                    transitionTaken = true;
{% else %}
                    LOG_DEBUG("AOT processTransition: State transition {} -> {}", static_cast<int>(currentState), static_cast<int>(State::{{ transition.target | capitalize }}));
                    currentState = State::{{ transition.target | capitalize }};
                    transitionTaken = true;
{% endif %}
{% endmacro %}

    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.needs_event_scheduler %}    static bool processTransition(State& currentState, Event event, Engine& engine) {
{% else %}    bool processTransition(State& currentState, Event event, Engine& engine) {
{% endif %}
{% if model.static_invokes %}
        // W3C SCXML 6.4: Check for pending done.invoke events
{% for invoke_info in model.static_invokes %}
        if (pendingDoneInvoke_{{ invoke_info.invoke_id }}_) {
            pendingDoneInvoke_{{ invoke_info.invoke_id }}_ = false;
            LOG_DEBUG("Raising done.invoke for {{ invoke_info.invoke_id }}");
            // W3C SCXML 6.4.3: done.invoke MUST be placed on external event queue
            engine.raiseExternal(typename Engine::EventWithMetadata(Event::Done_invoke));
        }
{% endfor %}
{% endif %}
{%- if model.needs_jsengine %}
        // W3C SCXML 5.3: Ensure JSEngine initialized to detect datamodel errors
        this->ensureJSEngine();

        // W3C SCXML 5.3: Raise error.execution and defer to next tick
        if (datamodelInitFailed_) {
            datamodelInitFailed_ = false;
            engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, "Datamodel initialization failed"));
            return false;
        }
{%- endif %}
{%- if model.needs_event_scheduler and model.needs_event_data and (model.needs_event_data_helper or model.needs_jsengine) %}


        // W3C SCXML 5.10: Retrieve event data from scheduled event map (test186)
        {
            auto it = scheduledEventData_.find(event);
            if (it != scheduledEventData_.end()) {
                pendingEventData_ = it->second;
                scheduledEventData_.erase(it);  // Clean up after retrieval
            }
        }
{%- endif %}
{%- if model.needs_event_name or model.needs_event_type %}


        // W3C SCXML 5.10: Store event name and type for _event.name and _event.type binding
        if (event != Event()) {  // Skip for eventless transitions
{% if model.needs_event_name %}
            pendingEventName_ = {{ model.name }}Policy::getEventName(event);
{% endif %}
{% if model.needs_event_type %}
            pendingEventType_ = this->getEventType(pendingEventName_);
{% endif %}
            LOG_DEBUG("AOT processTransition: Set pendingEventName='{}', pendingEventType='{}'", pendingEventName_, pendingEventType_);
        }
{%- endif %}
{%- if model.needs_jsengine and (model.needs_event_name or model.needs_event_data or model.needs_event_origin) %}


        // W3C SCXML 5.10: Set _event variable in JSEngine
        if (!pendingEventName_.empty() || !pendingEventData_.empty() || !pendingEventOrigin_.empty()) {
            LOG_DEBUG("AOT processTransition: Setting _event (name='{}', data='{}', type='{}', sendId='{}', origin='{}', invokeId='{}')",
                      pendingEventName_, pendingEventData_, pendingEventType_, pendingEventSendId_, pendingEventOrigin_, pendingEventInvokeId_);
            setCurrentEventInJSEngine(pendingEventName_, pendingEventData_, pendingEventType_, pendingEventSendId_, pendingEventOrigin_, pendingEventOriginType_, pendingEventInvokeId_);
        }
{%- endif %}

        (void)engine;
        LOG_DEBUG("AOT processTransition: Called with event={}, currentState={}", static_cast<int>(event), static_cast<int>(currentState));
        (void)event;
        bool transitionTaken = false;

        // W3C SCXML 3.12: Hierarchical event processing (innermost to outermost)
        // Match Interpreter engine's hierarchical transition logic:
        // Check transitions from current state up through parent hierarchy
        State checkState = currentState;

        while (true) {
            // Try to find a matching transition in checkState
            bool foundTransition = tryTransitionInState(checkState, event, currentState, transitionTaken, engine);

            if (foundTransition) {
                break;  // Transition taken, exit hierarchy check
            }

            // W3C SCXML 3.13: Eventless transitions do NOT bubble to parent states
            // Only check the current active state for eventless transitions
            if (event == Event()) {
                LOG_DEBUG("AOT processTransition: Eventless transition - not checking parent states");
                break;
            }

            // W3C SCXML 3.12: Move to parent state for hierarchical event bubbling (external events only)
            auto parent = {{ model.name }}Policy::getParent(checkState);
            if (!parent.has_value()) {
                // Reached root, no more parents to check
                break;
            }

            LOG_DEBUG("AOT processTransition: No transition in state {}, checking parent state {}",
                      static_cast<int>(checkState), static_cast<int>(parent.value()));
            checkState = parent.value();
        }

{% if model.needs_event_scheduler %}
        // W3C SCXML 6.2: Process ready scheduled events
        {
            Event scheduledEvent;
{% if model.needs_event_data_helper or model.needs_jsengine %}
            std::string eventData;
            while (eventScheduler_.popReadyEvent(scheduledEvent, eventData)) {
                if (!eventData.empty()) {
                    // W3C SCXML 5.10: Store event data in map for later retrieval (test186)
                    scheduledEventData_[scheduledEvent] = eventData;
                }
                engine.raise(scheduledEvent);
            }
{% else %}
            while (eventScheduler_.popReadyEvent(scheduledEvent)) {
                engine.raise(scheduledEvent);
            }
{% endif %}
        }

{% endif %}
{% if model.needs_event_name or model.needs_event_data %}
        // W3C SCXML 5.10: Clear event fields after processing
{% if model.needs_event_name %}
        pendingEventName_.clear();
{% endif %}
{% if model.needs_event_data %}
        pendingEventData_.clear();
{% endif %}
{% if model.needs_event_type %}
        pendingEventType_.clear();
{% endif %}
{% if model.needs_event_sendid %}
        pendingEventSendId_.clear();
{% endif %}
{% if model.needs_event_invokeid %}
        pendingEventInvokeId_.clear();
{% endif %}
{% endif %}

        return transitionTaken;
    }

private:
    // W3C SCXML 3.12: Helper method for hierarchical transition checking
    // Matches Interpreter engine's processStateTransitions() logic
    template<typename Engine>
{% if not model.needs_jsengine and not model.static_invokes and not model.needs_event_scheduler %}    static bool tryTransitionInState([[maybe_unused]] State checkState, [[maybe_unused]] Event event,
                                      [[maybe_unused]] State& currentState, [[maybe_unused]] bool& transitionTaken,
                                      [[maybe_unused]] Engine& engine) {
{% else %}    bool tryTransitionInState([[maybe_unused]] State checkState, [[maybe_unused]] Event event,
                              [[maybe_unused]] State& currentState, [[maybe_unused]] bool& transitionTaken,
                              [[maybe_unused]] Engine& engine) {
{% endif %}
        switch (checkState) {
{% for state_id, state in model.states.items() %}
        case State::{{ state_id | capitalize }}:
{% if state.transitions %}
{% set event_transitions = [] %}
{% set eventless_transitions = [] %}
{% for trans in state.transitions %}
{% if trans.event %}
{% set _ = event_transitions.append(trans) %}
{% else %}
{% set _ = eventless_transitions.append(trans) %}
{% endif %}
{% endfor %}
{% if event_transitions %}
{# W3C SCXML 3.12: Process transitions in strict document order (no grouping) #}
{# W3C SCXML 3.12.1: Prefix matching is applied during event comparison #}
{# Example: event="entering" matches "entering", "entering.s011", "entering.s012", etc. #}
{# CRITICAL: More specific events (entering.s011) must be checked BEFORE general events (entering) #}
{# Document order ensures this: if SCXML has entering.s011 before entering, check in that order #}
{% set prev_event = namespace(value='') %}
{% for trans in event_transitions %}
{# Generate event matching condition using prefix matching #}
{% if trans.event in ['*', '.*', '_*'] %}
            if (event != Event::NONE) {  // W3C SCXML 3.12: Wildcard matches any event except NONE
{% else %}
{% set events = trans.event.split() %}
{% if events | length > 1 %}
            if ({% for ev in events %}event == Event::{{ ev | replace('.', '_') | capitalize }}{% if not loop.last %} || {% endif %}{% endfor %}) {
{% elif trans.prefix_matching_events and trans.prefix_matching_events | length > 1 %}
            if ({% for ev in trans.prefix_matching_events %}event == Event::{{ ev | replace('.', '_') | capitalize }}{% if not loop.last %} || {% endif %}{% endfor %}) {
{% else %}
            if (event == Event::{{ trans.event | replace('.', '_') | capitalize }}) {
{% endif %}
{% endif %}
{# Initialize JSEngine if needed (only once per transition) #}
{% if model.needs_jsengine %}
                this->ensureJSEngine();
                [[maybe_unused]] auto& jsEngine = ::RSM::JSEngine::instance();
{% endif %}
{# Process single transition with its condition #}
{% if trans.cond %}
{% if model.needs_jsengine %}
                if (this->safeEvaluateGuard(jsEngine, sessionId_.value(), "{{ trans.cond | escape_cpp }}", engine)) {
{% else %}
                if ({{ trans.cond }}) {
{% endif %}
                    LOG_DEBUG("AOT processTransition: Event matched descriptor '{{ trans.event }}' in state {}", static_cast<int>(checkState));
{% for action in trans.actions %}
{% include 'actions/' + action.type + '.jinja2' %}
{% endfor %}
{% if trans.target %}
{{ restore_history_or_transition(trans) }}
{% endif %}
                    return true;  // Transition found
                }
{% else %}
                {  // Unconditional transition
                    LOG_DEBUG("AOT processTransition: Event matched descriptor '{{ trans.event }}' in state {}", static_cast<int>(checkState));
{% for action in trans.actions %}
{% include 'actions/' + action.type + '.jinja2' %}
{% endfor %}
{% if trans.target %}
{{ restore_history_or_transition(trans) }}
{% endif %}
                    return true;  // Transition found
                }
{% endif %}
            }
{% endfor %}
{% endif %}
{% if eventless_transitions %}
{% set has_any_guard = namespace(value=False) %}
{% for trans in eventless_transitions %}
{% if trans.cond %}
{% set has_any_guard.value = True %}
{% endif %}
{% endfor %}
{% if has_any_guard.value %}
{% set first_uses_jsengine = eventless_transitions[0].cond and model.needs_jsengine %}
{% if first_uses_jsengine %}
            {
                this->ensureJSEngine();
                auto& jsEngine = ::RSM::JSEngine::instance();
{% endif %}
{% set first_trans = namespace(value=True) %}
{% for transition in eventless_transitions %}
{% if transition.cond %}
{% if first_trans.value %}
{% if model.needs_jsengine %}
                if (this->safeEvaluateGuard(jsEngine, sessionId_.value(), "{{ transition.cond | escape_cpp }}", engine)) {
{% else %}
            if ({{ transition.cond }}) {
{% endif %}
{% set first_trans.value = False %}
{% else %}
{% if model.needs_jsengine and first_uses_jsengine %}
                } else if (this->safeEvaluateGuard(jsEngine, sessionId_.value(), "{{ transition.cond | escape_cpp }}", engine)) {
{% else %}
            } else if ({{ transition.cond }}) {
{% endif %}
{% endif %}
{% else %}
{% if not first_trans.value %}
                } else {
{% endif %}
{% set first_trans.value = False %}
{% endif %}
{% for action in transition.actions %}
{% include 'actions/' + action.type + '.jinja2' %}
{% endfor %}
{% if transition.target %}
                    LOG_DEBUG("AOT processTransition: State transition {} -> {}", static_cast<int>(currentState), static_cast<int>(State::{{ transition.target | capitalize }}));
                    currentState = State::{{ transition.target | capitalize }};
                    transitionTaken = true;
{% endif %}
                    return true;  // Eventless transition found
{% endfor %}
{% if eventless_transitions[0].cond %}
{% if model.needs_jsengine %}
                }
            }
{% else %}
            }
{% endif %}
{% else %}
                }
{% endif %}
{% else %}
{% for transition in eventless_transitions %}
{% for action in transition.actions %}
{% include 'actions/' + action.type + '.jinja2' %}
{% endfor %}
{% if transition.target %}
{{ restore_history_or_transition(transition) }}
{% endif %}
                    return true;  // Unconditional eventless transition
{% endfor %}
{% endif %}
{% endif %}
{% endif %}
            return false;  // No transition in this state
{% endfor %}
        default:
            return false;
        }
    }

public:
