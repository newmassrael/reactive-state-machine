#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <spdlog/fmt/fmt.h>
#include <string>

// Include parsing components
#include "common/Logger.h"
#include "factory/NodeFactory.h"
#include "model/SCXMLModel.h"
#include "parsing/SCXMLParser.h"

namespace fs = std::filesystem;

void printUsage(const char *programName) {
    RSM::Logger::info("SCXML Code Generator\n");
    RSM::Logger::info(fmt::format("Usage: {} [options] <input.scxml>\n", programName));
    RSM::Logger::info("Options:");
    RSM::Logger::info("  -o, --output <file>    Output file path (default: generated.cpp)");
    RSM::Logger::info("  -h, --help            Show this help message");
    RSM::Logger::info("  -v, --verbose         Enable verbose logging\n");
    RSM::Logger::info("Examples:");
    RSM::Logger::info(fmt::format("  {} state_machine.scxml", programName));
    RSM::Logger::info(fmt::format("  {} -o my_sm.cpp input.scxml", programName));
    RSM::Logger::info(fmt::format("  {} --verbose --output=generated.hpp input.scxml", programName));
}

void printVersion() {
    RSM::Logger::info("scxml-codegen version 1.0.0");
    RSM::Logger::info("SCXML-to-C++ Code Generator");
}

int main(int argc, char *argv[]) {
    std::string inputFile;
    std::string outputFile = "generated.cpp";
    bool verbose = false;

    // Parse command line arguments
    for (int i = 1; i < argc; ++i) {
        std::string arg(argv[i]);

        if (arg == "-h" || arg == "--help") {
            printUsage(argv[0]);
            return 0;
        } else if (arg == "-v" || arg == "--verbose") {
            verbose = true;
        } else if (arg == "--version") {
            printVersion();
            return 0;
        } else if (arg == "-o" || arg == "--output") {
            if (i + 1 < argc) {
                outputFile = argv[++i];
            } else {
                RSM::Logger::error("Error: --output requires a file path");
                return 1;
            }
        } else if (arg.starts_with("--output=")) {
            outputFile = arg.substr(9);
        } else if (arg.starts_with("-")) {
            RSM::Logger::error(fmt::format("Error: Unknown option {}", arg));
            printUsage(argv[0]);
            return 1;
        } else {
            if (inputFile.empty()) {
                inputFile = arg;
            } else {
                RSM::Logger::error("Error: Multiple input files specified");
                return 1;
            }
        }
    }

    // Validate arguments
    if (inputFile.empty()) {
        RSM::Logger::error("Error: No input file specified");
        printUsage(argv[0]);
        return 1;
    }

    if (!fs::exists(inputFile)) {
        RSM::Logger::error(fmt::format("Error: Input file '{}' does not exist", inputFile));
        return 1;
    }

    // Set logging level
    if (verbose) {
        // Logger는 정적 레벨 설정이 없으므로 현재는 무시
        RSM::Logger::info("Verbose mode enabled");
    }

    try {
        RSM::Logger::info("Starting SCXML code generation...");
        RSM::Logger::info(fmt::format("Input file: {}", inputFile));
        RSM::Logger::info(fmt::format("Output file: {}", outputFile));

        // Parse SCXML file
        auto nodeFactory = std::make_shared<RSM::NodeFactory>();
        RSM::SCXMLParser parser(nodeFactory);
        auto model = parser.parseFile(inputFile);

        if (!model) {
            RSM::Logger::error("Error: Failed to parse SCXML file");
            return 1;
        }

        RSM::Logger::info("SCXML parsing completed successfully");

        // Generate C++ code
        std::ofstream outFile(outputFile);
        if (!outFile.is_open()) {
            RSM::Logger::error(fmt::format("Error: Cannot create output file '{}'", outputFile));
            return 1;
        }

        // Generate header
        outFile << "// Generated by scxml-codegen from " << inputFile << "\n";
        outFile << "// Do not edit this file manually\n\n";
        outFile << "#include \"scxml/SCXMLEngine.h\"\n";
        outFile << "#include \"scxml/SCXMLTypes.h\"\n\n";

        // Generate state machine class
        std::string className = fs::path(inputFile).stem().string() + "StateMachine";
        outFile << "class " << className << " {\n";
        outFile << "public:\n";
        outFile << "    " << className << "() {\n";
        outFile << "        engine = SCXML::createSCXMLEngine();\n";
        outFile << "        engine->initialize();\n";
        outFile << "        engine->createSession(\"main\");\n";
        outFile << "    }\n\n";
        outFile << "    ~" << className << "() {\n";
        outFile << "        if (engine) {\n";
        outFile << "            engine->destroySession(\"main\");\n";
        outFile << "            engine->shutdown();\n";
        outFile << "        }\n";
        outFile << "    }\n\n";
        outFile << "    void start() {\n";
        outFile << "        // TODO: Generate state machine logic based on SCXML\n";
        outFile << "        // This is a placeholder implementation\n";
        outFile << "    }\n\n";
        outFile << "    void processEvent(const std::string& eventName) {\n";
        outFile << "        auto event = std::make_shared<SCXML::Event>(eventName);\n";
        outFile << "        engine->setCurrentEvent(\"main\", event);\n";
        outFile << "    }\n\n";
        outFile << "private:\n";
        outFile << "    std::unique_ptr<SCXML::SCXMLEngine> engine;\n";
        outFile << "};\n\n";

        // Generate usage example
        outFile << "// Usage example:\n";
        outFile << "// " << className << " sm;\n";
        outFile << "// sm.start();\n";
        outFile << "// sm.processEvent(\"user_input\");\n";

        outFile.close();

        RSM::Logger::info("Code generation completed successfully");
        RSM::Logger::info(fmt::format("Generated: {}", outputFile));

        return 0;

    } catch (const std::exception &e) {
        RSM::Logger::error(fmt::format("Error: {}", e.what()));
        return 1;
    }
}